"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalEvaluationClient = void 0;
const evaluation_js_1 = __importDefault(require("@amplitude/evaluation-js"));
const http_1 = require("../transport/http");
const config_1 = require("../types/config");
const logger_1 = require("../util/logger");
const cache_1 = require("./cache");
const fetcher_1 = require("./fetcher");
const poller_1 = require("./poller");
/**
 * Experiment client for evaluating variants for a user locally.
 * @category Core Usage
 */
class LocalEvaluationClient {
    constructor(apiKey, config, flagConfigCache = new cache_1.InMemoryFlagConfigCache(config === null || config === void 0 ? void 0 : config.bootstrap), httpClient = new http_1.FetchHttpClient(config === null || config === void 0 ? void 0 : config.httpAgent)) {
        this.config = Object.assign(Object.assign({}, config_1.LocalEvaluationDefaults), config);
        const fetcher = new fetcher_1.FlagConfigFetcher(apiKey, httpClient, this.config.serverUrl, this.config.debug);
        this.cache = flagConfigCache;
        this.logger = new logger_1.ConsoleLogger(this.config.debug);
        this.poller = new poller_1.FlagConfigPoller(fetcher, this.cache, this.config.flagConfigPollingIntervalMillis, this.config.debug);
    }
    /**
     * Locally evaluates flag variants for a user.
     *
     * This function will only evaluate flags for the keys specified in the
     * {@link flagKeys} argument. If {@link flagKeys} is missing, all flags in the
     * {@link FlagConfigCache} will be evaluated.
     *
     * @param user The user to evaluate
     * @param flagKeys The flags to evaluate with the user. If empty, all flags
     * from the flag cache are evaluated.
     * @returns The evaluated variants
     */
    evaluate(user, flagKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const flagConfigs = yield this.getFlagConfigs(flagKeys);
            this.logger.debug('[Experiment] evaluate - user:', user, 'flagConfigs:', flagConfigs);
            const results = evaluation_js_1.default.evaluate(flagConfigs, user);
            this.logger.debug('[Experiment] evaluate - result: ', results);
            return results;
        });
    }
    /**
     * Fetch initial flag configurations and start polling for updates.
     *
     * You must call this function to begin polling for flag config updates.
     * The promise returned by this function is resolved when the initial call
     * to fetch the flag configuration completes.
     *
     * Calling this function while the poller is already running does nothing.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.poller.start();
        });
    }
    /**
     * Stop polling for flag configurations.
     *
     * Calling this function while the poller is not running will do nothing.
     */
    stop() {
        return this.poller.stop();
    }
    getFlagConfigs(flagKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!flagKeys) {
                return Object.values(yield this.cache.getAll());
            }
            const result = [];
            for (const key of flagKeys) {
                const flagConfig = yield this.cache.get(key);
                if (flagConfig) {
                    result.push(flagConfig);
                }
            }
            return result;
        });
    }
}
exports.LocalEvaluationClient = LocalEvaluationClient;
