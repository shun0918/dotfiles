"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchHttpClient = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = __importDefault(require("url"));
const defaultHttpAgent = new https_1.default.Agent({
    keepAlive: true,
});
class FetchHttpClient {
    constructor(httpAgent) {
        this.httpAgent = httpAgent || defaultHttpAgent;
    }
    /**
     * Wraps the http and https libraries in a fetch()-like interface
     * @param requestUrl
     * @param method HTTP Method (GET, POST, etc.)
     * @param headers HTTP Headers
     * @param  Request body
     */
    request(requestUrl, method, headers, body, timeoutMillis) {
        return new Promise((resolve, reject) => {
            if (timeoutMillis === 0) {
                reject(Error('Response timed out'));
                return;
            }
            const urlParams = url_1.default.parse(requestUrl);
            const options = Object.assign(Object.assign({}, urlParams), { method: method, headers: headers, body: body, agent: this.httpAgent, timeout: timeoutMillis });
            const protocol = urlParams.protocol === 'http:' ? http_1.default : https_1.default;
            const req = protocol.request(options);
            req.on('response', (res) => {
                res.setEncoding('utf-8');
                let responseBody = '';
                res.on('data', (chunk) => {
                    responseBody += chunk;
                });
                res.on('end', () => {
                    resolve({
                        status: res.statusCode,
                        body: responseBody,
                    });
                });
            });
            req.on('timeout', () => {
                req.destroy(Error('Socket connection timed out'));
            });
            req.on('error', (e) => {
                reject(e);
            });
            if (method !== 'GET' && body) {
                req.write(body);
            }
            req.end();
        });
    }
}
exports.FetchHttpClient = FetchHttpClient;
