"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageServer = void 0;
const lodash_1 = __importDefault(require("lodash"));
const rxjs_1 = require("rxjs");
const integration_1 = require("../../cli/contants/integration");
const configuration_1 = require("../configuration/configuration");
const languageServer_1 = require("../constants/languageServer");
const settings_1 = require("../constants/settings");
const errorHandler_1 = require("../error/errorHandler");
const proxy_1 = require("../proxy");
const lsExecutable_1 = require("./lsExecutable");
const middleware_1 = require("./middleware");
const settings_2 = require("./settings");
class LanguageServer {
    constructor(user, configuration, languageClientAdapter, workspace, window, authenticationService, logger, downloadService, experimentService) {
        this.user = user;
        this.configuration = configuration;
        this.languageClientAdapter = languageClientAdapter;
        this.workspace = workspace;
        this.window = window;
        this.authenticationService = authenticationService;
        this.logger = logger;
        this.downloadService = downloadService;
        this.experimentService = experimentService;
        this.cliReady$ = new rxjs_1.ReplaySubject(1);
        this.scan$ = new rxjs_1.Subject();
        this.downloadService = downloadService;
    }
    // Starts the language server and the client. LS will be downloaded if missing.
    // Returns a promise that resolves when the language server is ready to receive requests.
    async start() {
        var _a, _b;
        // wait until Snyk LS is downloaded
        await (0, rxjs_1.firstValueFrom)(this.downloadService.downloadReady$);
        this.logger.info('Starting Snyk Language Server');
        // proxy settings
        const proxyOptions = await (0, proxy_1.getProxyOptions)(this.workspace, this.configuration, this.logger);
        const proxyEnvVariable = (0, proxy_1.getProxyEnvVariable)(proxyOptions);
        let processEnv = process.env;
        if (proxyEnvVariable) {
            processEnv = {
                ...processEnv,
                // eslint-disable-next-line camelcase
                https_proxy: proxyEnvVariable,
                // eslint-disable-next-line camelcase
                http_proxy: proxyEnvVariable,
            };
        }
        const lsBinaryPath = lsExecutable_1.LsExecutable.getPath(this.configuration.getSnykLanguageServerPath());
        this.logger.info(`Snyk Language Server path: ${lsBinaryPath}`);
        const serverOptions = {
            command: lsBinaryPath,
            args: ['-l', 'info'],
            options: {
                env: processEnv,
            },
        };
        // Options to control the language client
        const clientOptions = {
            documentSelector: [{ scheme: 'file', language: '' }],
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            initializationOptions: await this.getInitializationOptions(),
            synchronize: {
                configurationSection: settings_1.CONFIGURATION_IDENTIFIER,
            },
            middleware: new middleware_1.LanguageClientMiddleware(this.configuration, this.experimentService),
            /**
             * We reuse the output channel here as it's not properly disposed of by the language client (vscode-languageclient@8.0.0-next.2)
             * See: https://github.com/microsoft/vscode-languageserver-node/blob/cdf4d6fdaefe329ce417621cf0f8b14e0b9bb39d/client/src/common/client.ts#L2789
             */
            outputChannel: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.outputChannel) !== null && _b !== void 0 ? _b : this.window.createOutputChannel(languageServer_1.SNYK_LANGUAGE_SERVER_NAME),
        };
        // Create the language client and start the client.
        this.client = this.languageClientAdapter.create('Snyk LS', languageServer_1.SNYK_LANGUAGE_SERVER_NAME, serverOptions, clientOptions);
        this.client
            .onReady()
            .then(() => {
            this.registerListeners(this.client);
        })
            .catch((error) => errorHandler_1.ErrorHandler.handle(error, this.logger, error.message));
        // Start the client. This will also launch the server
        this.client.start();
        this.logger.info('Snyk Language Server started');
    }
    registerListeners(client) {
        client.onNotification(languageServer_1.SNYK_HAS_AUTHENTICATED, ({ token }) => {
            this.authenticationService.updateToken(token).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_CLI_PATH, ({ cliPath }) => {
            if (!cliPath) {
                errorHandler_1.ErrorHandler.handle(new Error("CLI path wasn't provided by language server on $/snyk.isAvailableCli notification " + cliPath), this.logger, "CLI path wasn't provided by language server on notification");
                return;
            }
            const currentCliPath = this.configuration.getCliPath();
            if (currentCliPath != cliPath) {
                this.logger.info('Setting Snyk CLI path to: ' + cliPath);
                void this.configuration
                    .setCliPath(cliPath)
                    .then(() => {
                    this.cliReady$.next(cliPath);
                })
                    .catch((error) => {
                    errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
                });
            }
        });
        client.onNotification(languageServer_1.SNYK_ADD_TRUSTED_FOLDERS, ({ trustedFolders }) => {
            this.configuration.setTrustedFolders(trustedFolders).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_SCAN, (scan) => {
            this.logger.info(`${lodash_1.default.capitalize(scan.product)} scan for ${scan.folderPath}: ${scan.status}.`);
            this.scan$.next(scan);
        });
    }
    // Initialization options are not semantically equal to server settings, thus separated here
    // https://github.com/microsoft/language-server-protocol/issues/567
    async getInitializationOptions() {
        const settings = await settings_2.LanguageServerSettings.fromConfiguration(this.configuration, this.experimentService);
        return {
            ...settings,
            integrationName: integration_1.CLI_INTEGRATION_NAME,
            integrationVersion: await configuration_1.Configuration.getVersion(),
            deviceId: this.user.anonymousId,
            automaticAuthentication: 'false',
        };
    }
    showOutputChannel() {
        if (!this.client) {
            return;
        }
        this.client.outputChannel.show();
    }
    async stop() {
        var _a;
        this.logger.info('Stopping Snyk Language Server...');
        if (!this.client) {
            return Promise.resolve();
        }
        if ((_a = this.client) === null || _a === void 0 ? void 0 : _a.needsStop()) {
            await this.client.stop();
        }
        this.logger.info('Snyk Language Server stopped');
    }
}
exports.LanguageServer = LanguageServer;
//# sourceMappingURL=languageServer.js.map