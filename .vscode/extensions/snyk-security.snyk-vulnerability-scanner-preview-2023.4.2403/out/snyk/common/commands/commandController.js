"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandController = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-argument */
const lodash_1 = __importDefault(require("lodash"));
const ignoreFileUtils_1 = require("../../snykCode/utils/ignoreFileUtils");
const issueUtils_1 = require("../../snykCode/utils/issueUtils");
const ossResult_1 = require("../../snykOss/ossResult");
const commands_1 = require("../constants/commands");
const general_1 = require("../constants/general");
const languageServer_1 = require("../constants/languageServer");
const errorHandler_1 = require("../error/errorHandler");
const types_1 = require("./types");
class CommandController {
    constructor(openerService, authService, snykCode, snykCodeOld, iacService, ossService, scanModeService, workspace, commands, window, languageServer, logger, analytics) {
        this.openerService = openerService;
        this.authService = authService;
        this.snykCode = snykCode;
        this.snykCodeOld = snykCodeOld;
        this.iacService = iacService;
        this.ossService = ossService;
        this.scanModeService = scanModeService;
        this.workspace = workspace;
        this.commands = commands;
        this.window = window;
        this.languageServer = languageServer;
        this.logger = logger;
        this.analytics = analytics;
        this.debouncedCommands = {};
    }
    openBrowser(url) {
        return this.executeCommand(commands_1.SNYK_OPEN_BROWSER_COMMAND, this.openerService.openBrowserUrl.bind(this), url);
    }
    async initiateLogin() {
        this.logger.info('Initiating login');
        await this.executeCommand(commands_1.SNYK_INITIATE_LOGIN_COMMAND, this.authService.initiateLogin.bind(this.authService));
        await this.commands.executeCommand(languageServer_1.SNYK_LOGIN_COMMAND);
        await this.commands.executeCommand(languageServer_1.SNYK_TRUST_WORKSPACE_FOLDERS_COMMAND);
    }
    async setToken() {
        await this.executeCommand(commands_1.SNYK_SET_TOKEN_COMMAND, this.authService.setToken.bind(this.authService));
    }
    async openLocal(path, range) {
        try {
            await this.window.showTextDocumentViaUri(path, { viewColumn: 1, selection: range });
        }
        catch (e) {
            errorHandler_1.ErrorHandler.handle(e, this.logger);
        }
    }
    async openLocalFile(filePath, range) {
        try {
            await this.window.showTextDocumentViaFilepath(filePath, { viewColumn: 1, selection: range });
        }
        catch (e) {
            errorHandler_1.ErrorHandler.handle(e, this.logger);
        }
    }
    openSettings() {
        void this.commands.executeCommand(commands_1.VSCODE_GO_TO_SETTINGS_COMMAND, `@ext:${general_1.SNYK_PUBLISHER}.${general_1.SNYK_NAME_EXTENSION}`);
    }
    async createDCIgnore(custom = false, uriAdapter, path) {
        if (!path) {
            const paths = this.workspace.getWorkspaceFolders();
            const promises = [];
            for (const p of paths) {
                promises.push((0, ignoreFileUtils_1.createDCIgnore)(p, custom, this.workspace, this.window, uriAdapter));
            }
            await Promise.all(promises);
        }
        else {
            await (0, ignoreFileUtils_1.createDCIgnore)(path, custom, this.workspace, this.window, uriAdapter);
        }
    }
    async openIssueCommand(arg) {
        if (arg.issueType == types_1.OpenCommandIssueType.CodeIssue) {
            const issueArgs = arg.issue;
            const issue = this.snykCode.getIssue(issueArgs.folderPath, issueArgs.id);
            if (!issue) {
                this.logger.warn(`Failed to find the issue ${issueArgs.id}.`);
                return;
            }
            await this.openLocalFile(issue.filePath, issueArgs.range);
            try {
                this.snykCode.showSuggestionProvider(issueArgs.folderPath, issueArgs.id);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger);
            }
            this.analytics.logIssueInTreeIsClicked({
                ide: general_1.IDE_NAME,
                issueId: decodeURIComponent(issue.id),
                issueType: issueUtils_1.IssueUtils.getIssueType(issue.additionalData.isSecurityType),
                severity: issueUtils_1.IssueUtils.issueSeverityAsText(issue.severity),
            });
        }
        else if (arg.issueType == types_1.OpenCommandIssueType.CodeIssueOld) {
            const issue = arg.issue;
            const suggestion = this.snykCodeOld.analyzer.findSuggestion(issue.diagnostic);
            if (!suggestion)
                return;
            // Set openUri = null to avoid opening the file (e.g. in the ActionProvider)
            await this.openLocal(issue.filePath, issue.range);
            try {
                this.snykCodeOld.suggestionProvider.show(suggestion.id, issue.filePath, issue.range);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger);
            }
            this.analytics.logIssueInTreeIsClicked({
                ide: general_1.IDE_NAME,
                issueId: decodeURIComponent(suggestion.id),
                issueType: issueUtils_1.IssueUtils.getIssueType(suggestion.isSecurityType),
                severity: issueUtils_1.IssueUtils.severityAsText(suggestion.severity),
            });
        }
        else if (arg.issueType == types_1.OpenCommandIssueType.OssVulnerability) {
            const issue = arg.issue;
            void this.ossService.showSuggestionProvider(issue);
            this.analytics.logIssueInTreeIsClicked({
                ide: general_1.IDE_NAME,
                issueId: issue.id,
                issueType: 'Open Source Vulnerability',
                severity: (0, ossResult_1.capitalizeOssSeverity)(issue.severity),
            });
        }
        else if (arg.issueType == types_1.OpenCommandIssueType.IacIssue) {
            const issueArgs = arg.issue;
            const issue = this.iacService.getIssue(issueArgs.folderPath, issueArgs.id);
            if (!issue) {
                this.logger.warn(`Failed to find the issue ${issueArgs.id}.`);
                return;
            }
            await this.openLocalFile(issue.filePath, issueArgs.range);
            try {
                this.iacService.showSuggestionProvider(issueArgs.folderPath, issueArgs.id);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger);
            }
            this.analytics.logIssueInTreeIsClicked({
                ide: general_1.IDE_NAME,
                issueId: issue.id,
                issueType: 'Infrastructure as Code Issue',
                severity: issueUtils_1.IssueUtils.issueSeverityAsText(issue.severity),
            });
        }
    }
    showOutputChannel() {
        return this.logger.showOutput();
    }
    showLsOutputChannel() {
        // To get an instance of an OutputChannel use createOutputChannel.
        return this.languageServer.showOutputChannel();
    }
    async executeCommand(name, fn, ...args) {
        if (!this.debouncedCommands[name])
            this.debouncedCommands[name] = lodash_1.default.debounce(async (...args) => {
                try {
                    return await fn(...args);
                }
                catch (error) {
                    errorHandler_1.ErrorHandler.handle(error, this.logger);
                    return Promise.resolve();
                }
            }, general_1.COMMAND_DEBOUNCE_INTERVAL, { leading: true, trailing: false });
        return this.debouncedCommands[name](...args);
    }
}
exports.CommandController = CommandController;
//# sourceMappingURL=commandController.js.map