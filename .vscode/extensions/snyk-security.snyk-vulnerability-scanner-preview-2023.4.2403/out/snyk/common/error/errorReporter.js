"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorReporter = exports.TagKeys = void 0;
const Sentry = __importStar(require("@sentry/node"));
const configuration_1 = require("../configuration/configuration");
const platform_1 = require("../platform");
const onUncaughtException_1 = require("./integrations/onUncaughtException");
var TagKeys;
(function (TagKeys) {
    TagKeys["CodeRequestId"] = "code_request_id";
})(TagKeys = exports.TagKeys || (exports.TagKeys = {}));
class ErrorReporter {
    static async init(userConfig, snykConfig, extensionPath, vscodeEnv, logger, transport) {
        if (!snykConfig.sentryKey) {
            logger.warn('Error reporting not initialized - key not provided.');
            return;
        }
        Sentry.init({
            dsn: snykConfig.sentryKey,
            maxBreadcrumbs: 50,
            debug: userConfig.isDevelopment,
            environment: await ErrorReporter.getEnvironment(userConfig),
            release: await configuration_1.Configuration.getVersion(),
            transport,
            integrations(integrations) {
                return [
                    ...integrations.filter(integration => !ErrorReporter.nonValidIntegrations.map(i => i.toLowerCase()).includes(integration.name.toLowerCase())),
                    new onUncaughtException_1.OnUncaughtException({ extensionPath }), // custom integration for uncaught exceptions
                ];
            },
            beforeSend(event) {
                // drop reporting, if user doesn't want to report events here
                // https://github.com/getsentry/sentry-javascript/issues/2039
                if (!userConfig.shouldReportErrors) {
                    return null;
                }
                event.contexts = ErrorReporter.getContexts(vscodeEnv, event.contexts);
                return event;
            },
        });
    }
    static capture(e, tags) {
        const isInitialized = Sentry.getCurrentHub().getClient();
        if (isInitialized) {
            if (tags && Object.keys(tags).length > 0) {
                Sentry.withScope(scope => {
                    Object.keys(tags).forEach(tag => scope.setTag(tag, tags[tag]));
                    return Sentry.captureException(e);
                });
            }
            else {
                return Sentry.captureException(e);
            }
        }
    }
    static identify(user) {
        Sentry.setUser({
            id: user.hashedAuthenticatedId,
        });
    }
    static flush() {
        return Sentry.close(this.eventQueueTimeoutMs);
    }
    static getContexts(vscodeEnv, contexts) {
        return {
            ...contexts,
            os: {
                name: platform_1.Platform.getCurrent(),
                version: platform_1.Platform.getVersion(),
            },
            vscode: {
                appName: vscodeEnv.getAppName(),
                appHost: vscodeEnv.getAppHost(),
                uiKind: vscodeEnv.getUiKind(),
                remoteName: vscodeEnv.getRemoteName(),
            },
        };
    }
    static async getEnvironment(userConfig) {
        if (userConfig.isDevelopment) {
            return 'development';
        }
        else if (await configuration_1.Configuration.isPreview()) {
            return 'preview';
        }
        return 'production';
    }
}
exports.ErrorReporter = ErrorReporter;
ErrorReporter.eventQueueTimeoutMs = 1000;
/**
 * 'OnUncaughException' integration must be ignored since it causes Sentry to permanently fail during runtime. Default Sentry behaviour is to call process.exit() for uncaught errors.
 * This is being prevented by VS Code and is logged as:
 * --- "An extension called process.exit() and this was prevented.".
 * As a result, Sentry shuts down and doesn't log any caught errors:
 * --- "Sentry Logger [Warn]: uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown".
 *
 * 'OnUnhandledRejection' must be ignored as well, since it captures unhandled rejections from other extensions running in the extension host and there's no way to determine which extension does the unhandled rejection belong to.
 *
 * Integrations reference: https://docs.sentry.io/platforms/node/configuration/integrations/default-integrations/
 */
ErrorReporter.nonValidIntegrations = [
    Sentry.Integrations.OnUncaughtException.id,
    Sentry.Integrations.OnUnhandledRejection.id,
];
//# sourceMappingURL=errorReporter.js.map