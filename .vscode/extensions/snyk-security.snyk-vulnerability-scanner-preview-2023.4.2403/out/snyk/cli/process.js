"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliProcess = void 0;
const child_process_1 = require("child_process");
const configuration_1 = require("../common/configuration/configuration");
const proxy_1 = require("../common/proxy");
const integration_1 = require("./contants/integration");
const cliService_1 = require("./services/cliService");
class CliProcess {
    constructor(logger, config, workspace) {
        this.logger = logger;
        this.config = config;
        this.workspace = workspace;
        this.successExitCodes = [0, 1];
    }
    /**
     * Returns CLI output given provided arguments.
     */
    async spawn(cliPath, cwd, args) {
        const processEnv = await this.getProcessEnv();
        return new Promise((resolve, reject) => {
            let output = '';
            this.logger.info(`Running "${cliPath} ${args.join(' ')}".`);
            this.runningProcess = (0, child_process_1.spawn)(cliPath, args, { env: { ...process.env, ...processEnv }, cwd });
            this.runningProcess.stdout.setEncoding('utf8');
            this.runningProcess.stdout.on('data', (data) => (output += data));
            this.runningProcess.on('error', err => {
                this.cleanupProcess();
                reject(err);
            });
            this.runningProcess.on('close', (_, signal) => {
                this.cleanupProcess();
                // Cancellation process kill was issued
                if (signal === 'SIGTERM') {
                    return reject(new cliService_1.CliError('', '', true));
                }
                // Treat as succesful termination
                resolve(output);
            });
        });
    }
    kill() {
        return !this.runningProcess || this.runningProcess.kill('SIGTERM');
    }
    async getProcessEnv() {
        let env = {
            SNYK_INTEGRATION_NAME: integration_1.CLI_INTEGRATION_NAME,
            SNYK_INTEGRATION_VERSION: await configuration_1.Configuration.getVersion(),
            SNYK_TOKEN: await this.config.getToken(),
            SNYK_API: this.config.snykOssApiEndpoint,
            SNYK_CFG_ORG: this.config.organization,
        };
        if (!this.config.shouldReportEvents) {
            env = { ...env, SNYK_CFG_DISABLE_ANALYTICS: '1' };
        }
        const vscodeProxy = (0, proxy_1.getVsCodeProxy)(this.workspace);
        if (vscodeProxy && !process.env.HTTP_PROXY && !process.env.HTTPS_PROXY) {
            env = {
                ...env,
                HTTP_PROXY: vscodeProxy,
                HTTPS_PROXY: vscodeProxy,
            };
        }
        return env;
    }
    cleanupProcess() {
        if (this.runningProcess) {
            this.runningProcess.removeAllListeners();
            this.runningProcess = null;
        }
    }
}
exports.CliProcess = CliProcess;
//# sourceMappingURL=process.js.map