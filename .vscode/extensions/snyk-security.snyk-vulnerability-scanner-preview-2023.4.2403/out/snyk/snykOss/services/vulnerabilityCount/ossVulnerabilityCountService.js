"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OssVulnerabilityCountService = exports.SupportedLanguage = void 0;
const languageConsts_1 = require("../../../common/constants/languageConsts");
const parsing_1 = require("../../../common/parsing");
const moduleParserProvider_1 = require("../../../common/services/moduleParserProvider");
const types_1 = require("../../../common/types");
const analysis_1 = require("../../../snykCode/constants/analysis");
const vulnerabilityCodeActionProvider_1 = require("../../codeActions/vulnerabilityCodeActionProvider");
const vulnerabilityCountHoverProvider_1 = require("../../hoverProvider/vulnerabilityCountHoverProvider");
const vulnerabilityCount_1 = require("../../messages/vulnerabilityCount");
const vulnerabilityCountEmitter_1 = require("../../vulnerabilityCountEmitter");
const importedModule_1 = require("./importedModule");
var SupportedLanguage;
(function (SupportedLanguage) {
    SupportedLanguage[SupportedLanguage["TypeScript"] = 0] = "TypeScript";
    SupportedLanguage[SupportedLanguage["JavaScript"] = 1] = "JavaScript";
    SupportedLanguage[SupportedLanguage["HTML"] = 2] = "HTML";
    SupportedLanguage[SupportedLanguage["PJSON"] = 3] = "PJSON";
})(SupportedLanguage = exports.SupportedLanguage || (exports.SupportedLanguage = {}));
class OssVulnerabilityCountService {
    constructor(workspace, window, languages, vulnerabilityCountProvider, ossService, logger, editorDecorator, codeActionKindProvider, analytics, configuration) {
        this.workspace = workspace;
        this.window = window;
        this.languages = languages;
        this.vulnerabilityCountProvider = vulnerabilityCountProvider;
        this.ossService = ossService;
        this.logger = logger;
        this.editorDecorator = editorDecorator;
        this.codeActionKindProvider = codeActionKindProvider;
        this.analytics = analytics;
        this.configuration = configuration;
        this.disposables = [];
        this.fileEmitters = new Map();
    }
    activate() {
        this.disposables.push((this.diagnostics = this.languages.createDiagnosticCollection(analysis_1.DIAGNOSTICS_OSS_COLLECTION_NAME)), this.workspace.onDidChangeTextDocument(ev => {
            if (ev.contentChanges.length) {
                this.processFile(ev.document);
            }
        }), this.window.onDidChangeActiveTextEditor(ev => {
            if (ev) {
                this.processFile(ev.document);
            }
        }), 
        // register hover provider
        new vulnerabilityCountHoverProvider_1.VulnerabilityCountHoverProvider(this.languages, this.analytics).register(this.diagnostics));
        // Subscribe to OSS scan finished updates
        this.ossScanFinishedSubscription = this.ossService.scanFinished$.subscribe(() => this.processActiveEditor());
        [languageConsts_1.JAVASCRIPT, languageConsts_1.TYPESCRIPT, languageConsts_1.PJSON, languageConsts_1.HTML].forEach(language => {
            const provider = new vulnerabilityCodeActionProvider_1.VulnerabilityCodeActionProvider(this.ossService, this.vulnerabilityCountProvider, this.codeActionKindProvider, this.analytics);
            this.disposables.push(this.languages.registerCodeActionsProvider(language, provider, {
                providedCodeActionKinds: provider.codeActionKinds,
            }));
        });
        this.processActiveEditor();
        return true;
    }
    processActiveEditor() {
        const activeEditor = this.window.getActiveTextEditor();
        if (activeEditor) {
            this.processFile(activeEditor.document);
        }
    }
    dispose() {
        while (this.disposables.length) {
            const disposable = this.disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
        for (const emitter of this.fileEmitters.values()) {
            emitter.removeAllListeners();
        }
        this.ossScanFinishedSubscription.unsubscribe();
    }
    processFile(document) {
        if (!document) {
            return false;
        }
        const { fileName, languageId } = document;
        const supportedLanguage = (0, parsing_1.getSupportedLanguage)(fileName, languageId);
        if (supportedLanguage === null || !this.shouldProcessFile(fileName, supportedLanguage)) {
            return false;
        }
        let emitter = this.fileEmitters.get(fileName);
        if (emitter) {
            emitter.removeAllListeners();
        }
        else {
            emitter = new vulnerabilityCountEmitter_1.VulnerabilityCountEmitter();
            this.fileEmitters.set(fileName, emitter);
        }
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Error, e => {
            this.logger.error(`Error counting module vulnerabilities: ${e}`);
            this.editorDecorator.resetDecorations(fileName);
        });
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Start, (modules) => {
            this.editorDecorator.setScanStartDecorations(fileName, modules);
        });
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Scanned, (vulnerabilityCount) => {
            this.editorDecorator.setScannedDecoration(vulnerabilityCount, true);
        });
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Done, (modules) => {
            this.editorDecorator.setScanDoneDecorations(fileName, modules);
            this.updateDiagnostics(document, modules);
        });
        // Start
        void this.getImportedModules(fileName, document.getText(), supportedLanguage, emitter);
        return true;
    }
    updateDiagnostics(document, modules) {
        if (!this.diagnostics) {
            return;
        }
        const diagnostics = [];
        for (const module of modules) {
            if (!module.hasCount || !module.range) {
                continue;
            }
            const diagnosticMessage = this.getDiagnosticMessage(module);
            if (!diagnosticMessage.length) {
                continue;
            }
            const range = this.languages.createRange(module.range.start.line - 1, module.range.start.column, module.range.end.line - 1, module.range.end.column);
            const diagnostic = this.languages.createDiagnostic(range, diagnosticMessage, 1); // Warning severity
            diagnostics.push({
                ...diagnostic,
                source: analysis_1.DIAGNOSTICS_OSS_COLLECTION_NAME,
                code: module.mostSevereVulnerabilityId,
            });
        }
        this.diagnostics.set(document.uri, diagnostics);
    }
    shouldProcessFile(fileName, language) {
        if ([types_1.Language.TypeScript, types_1.Language.JavaScript, types_1.Language.PJSON].includes(language)) {
            const ossResult = this.ossService.getResultArray();
            if (!ossResult) {
                return false;
            }
            for (const fileResult of ossResult) {
                if (this.vulnerabilityCountProvider.isFilePartOfOssTest(fileName, fileResult)) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    async getImportedModules(fileName, content, language, emitter) {
        try {
            const modules = this.getModules(fileName, content, language).filter(parsing_1.isValidModuleName);
            emitter.startScanning(modules);
            const promises = modules
                .map(module => this.vulnerabilityCountProvider.getVulnerabilityCount(module, language))
                .map(promise => promise.then(module => {
                emitter.scanned(module);
                return module;
            }));
            const testedModules = await Promise.all(promises);
            emitter.done(testedModules);
        }
        catch (e) {
            emitter.error(e);
        }
    }
    getModules(fileName, source, language) {
        const parser = moduleParserProvider_1.ModuleParserProvider.getInstance(language, this.logger, this.configuration);
        if (!parser) {
            return [];
        }
        return parser.getModules(fileName, source, language);
    }
    getDiagnosticMessage(module) {
        if (!module.count) {
            return '';
        }
        let message = vulnerabilityCount_1.messages.diagnosticMessagePrefix(module);
        message += this.getSeverityCountMessage([
            importedModule_1.ModuleVulnerabilityCountSeverity.Critical,
            importedModule_1.ModuleVulnerabilityCountSeverity.High,
            importedModule_1.ModuleVulnerabilityCountSeverity.Medium,
            importedModule_1.ModuleVulnerabilityCountSeverity.Low,
        ], module);
        message += module.count > 1 ? ` ${vulnerabilityCount_1.messages.vulnerabilities}.` : ` ${vulnerabilityCount_1.messages.vulnerabilities}.`;
        return message;
    }
    getSeverityCountMessage(severities, module) {
        if (!module.severityCounts) {
            return module.count ? module.count.toString() : '';
        }
        const content = [];
        for (const severity of severities) {
            if (module.severityCounts[severity] > 0) {
                content.push(`${module.severityCounts[severity]} ${severity}`);
            }
        }
        return content.join(', ');
    }
}
exports.OssVulnerabilityCountService = OssVulnerabilityCountService;
//# sourceMappingURL=ossVulnerabilityCountService.js.map