"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAbsoluteMarkerFilePath = exports.isSecurityTypeSuggestion = exports.ignoreIssueCommentText = exports.findSuggestionByMessage = exports.checkCompleteSuggestion = exports.findCompleteSuggestion = exports.createIssueRelatedInformation = exports.createIssuesMarkersDecorationOptions = exports.createIssueMarkerMsg = exports.updateFileReviewResultsPositions = exports.createIssueCorrectRange = exports.createIssueRange = exports.createSnykProgress = exports.getSnykSeverity = exports.getVSCodeSeverity = exports.createSnykSeveritiesMap = void 0;
const path_1 = __importDefault(require("path"));
const types_1 = require("../../common/vscode/types");
const analysis_1 = require("../constants/analysis");
const issueUtils_1 = require("./issueUtils");
const createSnykSeveritiesMap = () => {
    const { information, error, warning } = analysis_1.SNYK_SEVERITIES;
    return {
        [information]: {
            name: types_1.DiagnosticSeverity.Information,
        },
        [warning]: { name: types_1.DiagnosticSeverity.Warning },
        [error]: { name: types_1.DiagnosticSeverity.Error },
    };
};
exports.createSnykSeveritiesMap = createSnykSeveritiesMap;
const getVSCodeSeverity = (snykSeverity) => {
    const { information, error, warning } = analysis_1.SNYK_SEVERITIES;
    return ({
        [information]: types_1.DiagnosticSeverity.Information,
        [warning]: types_1.DiagnosticSeverity.Warning,
        [error]: types_1.DiagnosticSeverity.Error,
    }[snykSeverity] || types_1.DiagnosticSeverity.Information);
};
exports.getVSCodeSeverity = getVSCodeSeverity;
const getSnykSeverity = (vscodeSeverity) => {
    const { information, error, warning } = analysis_1.SNYK_SEVERITIES;
    return {
        [types_1.DiagnosticSeverity.Information]: information,
        [types_1.DiagnosticSeverity.Warning]: warning,
        [types_1.DiagnosticSeverity.Error]: error,
        [types_1.DiagnosticSeverity.Hint]: information,
    }[vscodeSeverity];
};
exports.getSnykSeverity = getSnykSeverity;
const createSnykProgress = (progress) => {
    const progressOffset = 100;
    return Math.round(progress * progressOffset);
};
exports.createSnykProgress = createSnykProgress;
const createIssueRange = (position, languages) => {
    return languages.createRange(Math.max(0, position.rows.start), Math.max(0, position.cols.start), Math.max(0, position.rows.end), Math.max(0, position.cols.end));
};
exports.createIssueRange = createIssueRange;
// todo: remove when Snyk Code uses LS.
const createIssueCorrectRange = (issuePosition, languages) => {
    return (0, exports.createIssueRange)({
        ...issueUtils_1.IssueUtils.createCorrectIssuePlacement(issuePosition),
    }, languages);
};
exports.createIssueCorrectRange = createIssueCorrectRange;
const updateFileReviewResultsPositions = (analysisResults, updatedFile) => {
    const changesRange = updatedFile.contentChanges[0].range;
    const changesText = updatedFile.contentChanges[0].text;
    const goToNewLine = '\n';
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    const offsetedline = changesRange.start.line + 1;
    const charOffset = 1;
    const fileIssuesList = {
        ...analysisResults.files[updatedFile.fullPath],
    };
    for (const issue in fileIssuesList) {
        if (!Object.prototype.hasOwnProperty.call(fileIssuesList, issue)) {
            continue;
        }
        for (const [index, position] of fileIssuesList[issue].entries()) {
            const currentLineIsOnEdgeOfIssueRange = offsetedline === position.rows[0] || offsetedline === position.rows[1];
            for (const row in position.rows) {
                if (offsetedline < position.rows[row]) {
                    position.rows[row] += updatedFile.lineCount.prevOffset;
                }
                else if (offsetedline === position.rows[row]) {
                    if (changesRange.start.character < position.rows[row]) {
                        position.rows[row] += updatedFile.lineCount.prevOffset;
                    }
                }
            }
            if (currentLineIsOnEdgeOfIssueRange || (offsetedline > position.rows[0] && offsetedline < position.rows[1])) {
                // when chars are added
                if (changesText.length && changesText !== goToNewLine && currentLineIsOnEdgeOfIssueRange) {
                    if (changesRange.start.character < position.cols[0] && !changesText.includes(goToNewLine)) {
                        for (const col in position.cols) {
                            if (!Object.prototype.hasOwnProperty.call(position.cols, col))
                                continue;
                            position.cols[col] += changesText.length;
                        }
                    }
                    // if char is inside issue range
                    if (changesRange.start.character >= position.cols[0] && changesRange.start.character <= position.cols[1]) {
                        position.cols[1] += changesText.length;
                    }
                }
                // when chars are deleted
                if (updatedFile.contentChanges[0].rangeLength && currentLineIsOnEdgeOfIssueRange) {
                    if (updatedFile.lineCount.prevOffset < 0 && !changesText) {
                        continue;
                    }
                    if (changesRange.start.character < position.cols[0] && !changesText.includes(goToNewLine)) {
                        for (const char in position.cols) {
                            if (!Object.prototype.hasOwnProperty.call(position.cols, char))
                                continue;
                            position.cols[char] =
                                position.cols[char] > 0 ? position.cols[char] - updatedFile.contentChanges[0].rangeLength : 0;
                        }
                    }
                    // if char is in issue range
                    if (changesRange.start.character >= position.cols[0] && changesRange.start.character <= position.cols[1]) {
                        position.cols[1] = position.cols[1] > 0 ? position.cols[1] - updatedFile.contentChanges[0].rangeLength : 0;
                    }
                }
                // hide issue
                if (position.cols[0] - charOffset === position.cols[1]) {
                    fileIssuesList[issue].splice(index, 1);
                }
                position.cols[0] = position.cols[0] > 0 ? position.cols[0] : 0;
                position.cols[1] = position.cols[1] > 0 ? position.cols[1] : 0;
            }
        }
    }
    return fileIssuesList;
};
exports.updateFileReviewResultsPositions = updateFileReviewResultsPositions;
const createIssueMarkerMsg = (originalMsg, [markerStartIdx, markerEndIdx]) => {
    return originalMsg.substring(markerStartIdx, markerEndIdx + 1);
};
exports.createIssueMarkerMsg = createIssueMarkerMsg;
const createIssuesMarkersDecorationOptions = (currentFileReviewIssues) => {
    if (!currentFileReviewIssues) {
        return [];
    }
    const issueMarkersDecorationOptions = currentFileReviewIssues.reduce((markersRanges, issue) => {
        if (issue.relatedInformation) {
            for (const markerInfo of issue.relatedInformation) {
                markersRanges.push({
                    range: markerInfo.location.range,
                    hoverMessage: markerInfo.message,
                });
            }
        }
        return markersRanges;
    }, Array());
    return issueMarkersDecorationOptions;
};
exports.createIssuesMarkersDecorationOptions = createIssuesMarkersDecorationOptions;
const createIssueRelatedInformation = (markersList, fileUriPath, message, languages, workspace, uriAdapter) => {
    return markersList.reduce((res, marker) => {
        const { msg: markerMsgIdxs, pos: positions } = marker;
        positions.forEach(position => {
            const positionUri = (0, exports.getAbsoluteMarkerFilePath)(workspace, position.file, fileUriPath);
            const relatedInfo = languages.createDiagnosticRelatedInformation(uriAdapter.file(positionUri), (0, exports.createIssueCorrectRange)(position, languages), (0, exports.createIssueMarkerMsg)(message, markerMsgIdxs));
            res.push(relatedInfo);
        });
        return res;
    }, Array());
};
exports.createIssueRelatedInformation = createIssueRelatedInformation;
const findCompleteSuggestion = (analysisResults, suggestionId, uri, position, languages) => {
    const filePath = uri.fsPath;
    if (!analysisResults.files[filePath])
        return;
    const file = analysisResults.files[filePath];
    let fileSuggestion;
    let suggestionIndex = Object.keys(file).find(i => {
        const index = parseInt(i, 10);
        if (analysisResults.suggestions[index].id !== suggestionId)
            return false;
        const pos = file[index].find(fs => {
            const r = (0, exports.createIssueCorrectRange)(fs, languages);
            return (r.start.character === position.start.character &&
                r.start.line === position.start.line &&
                r.end.character === position.end.character &&
                r.end.line === position.end.line);
        });
        if (pos) {
            fileSuggestion = pos;
            return true;
        }
        return false;
    });
    if (!fileSuggestion || !suggestionIndex)
        return;
    suggestionIndex = parseInt(suggestionIndex, 10);
    const suggestion = analysisResults.suggestions[suggestionIndex];
    if (!suggestion)
        return;
    // eslint-disable-next-line consistent-return
    return {
        uri: uri.toString(),
        ...suggestion,
        ...fileSuggestion,
    };
};
exports.findCompleteSuggestion = findCompleteSuggestion;
const checkCompleteSuggestion = (analysisResults, suggestion, uriAdapter) => {
    const filePath = uriAdapter.parse(suggestion.uri).fsPath;
    if (!analysisResults.files[filePath])
        return false;
    const file = analysisResults.files[filePath];
    const suggestionIndex = Object.keys(file).find(i => {
        const index = parseInt(i, 10);
        if (analysisResults.suggestions[index].id !== suggestion.id ||
            analysisResults.suggestions[index].message !== suggestion.message)
            return false;
        const found = file[index].find(fs => {
            let equal = true;
            for (const dir of ['cols', 'rows']) {
                for (const ind of [0, 1]) {
                    equal = equal && fs[dir][ind] === suggestion[dir][ind];
                }
            }
            return equal;
        });
        return !!found;
    });
    return !!suggestionIndex;
};
exports.checkCompleteSuggestion = checkCompleteSuggestion;
const findSuggestionByMessage = (analysisResults, suggestionName) => {
    return Object.values(analysisResults.suggestions).find((suggestion) => suggestion.message === suggestionName);
};
exports.findSuggestionByMessage = findSuggestionByMessage;
const ignoreIssueCommentText = (issueId, isFileIgnore) => {
    const snykComment = isFileIgnore ? analysis_1.FILE_IGNORE_ISSUE_BASE_COMMENT_TEXT : analysis_1.IGNORE_ISSUE_BASE_COMMENT_TEXT;
    return `${snykComment} ${issueId}: ${analysis_1.IGNORE_ISSUE_REASON_TIP}`;
};
exports.ignoreIssueCommentText = ignoreIssueCommentText;
const isSecurityTypeSuggestion = (suggestion) => {
    return suggestion.categories.includes('Security');
};
exports.isSecurityTypeSuggestion = isSecurityTypeSuggestion;
const getAbsoluteMarkerFilePath = (workspace, markerFilePath, suggestionFilePath) => {
    if (!markerFilePath) {
        // If no filePath reported, use suggestion file path as marker's path. Suggestion path is always absolute.
        return suggestionFilePath;
    }
    const workspaceFolders = workspace.getWorkspaceFolders();
    if (workspaceFolders.length > 1) {
        return markerFilePath;
    }
    // The Snyk Code analysis reported marker path is relative when in workspace with a single folder, thus need to convert to an absolute
    return path_1.default.resolve(workspaceFolders[0], markerFilePath);
};
exports.getAbsoluteMarkerFilePath = getAbsoluteMarkerFilePath;
//# sourceMappingURL=analysisUtils.js.map