"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FalsePositive = void 0;
const analysisUtils_1 = require("../utils/analysisUtils");
const issueUtils_1 = require("../utils/issueUtils");
class FalsePositive {
    constructor(workspace, suggestion) {
        this.workspace = workspace;
        if (!suggestion.markers || suggestion.markers.length === 0) {
            throw new Error('Cannot create false positive without markers.');
        }
        this.message = suggestion.message;
        this.id = decodeURIComponent(suggestion.id);
        this.rule = suggestion.rule;
        this.primaryFilePath = suggestion.uri;
        const issuePosition = issueUtils_1.IssueUtils.createCorrectIssuePlacement(suggestion);
        this.startLine = issuePosition.rows.start;
        this.endLine = issuePosition.rows.end;
        this.files = this.getFiles(suggestion.markers, suggestion.uri);
    }
    getFiles(markers, uri) {
        const markerPositions = markers.flatMap(marker => marker.pos);
        const filesArray = markerPositions.map(markerPosition => (0, analysisUtils_1.getAbsoluteMarkerFilePath)(this.workspace, markerPosition.file, uri));
        return new Set(filesArray);
    }
    /**
     * May throw an error if file cannot be resolved.
     */
    async getGeneratedContent() {
        let content = this.getMainHeader();
        for await (const file of this.files) {
            const doc = await this.workspace.openFileTextDocument(file);
            content += this.appendFileHeader(doc.getText(), file);
        }
        return content;
    }
    getMainHeader() {
        return `/**
 * The following code will be uploaded to Snyk to be reviewed.
 * Make sure there are no sensitive information sent.
 */

`;
    }
    appendFileHeader(text, filePath) {
        return `/**
 * Code from ${filePath}
 */
${text}`;
    }
}
exports.FalsePositive = FalsePositive;
//# sourceMappingURL=falsePositive.js.map