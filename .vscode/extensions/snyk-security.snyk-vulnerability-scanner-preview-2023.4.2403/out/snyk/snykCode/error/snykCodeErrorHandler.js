"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnykCodeErrorHandler = void 0;
const code_client_1 = require("@snyk/code-client");
const general_1 = require("../../common/constants/general");
const views_1 = require("../../common/constants/views");
const errorHandler_1 = require("../../common/error/errorHandler");
const errorReporter_1 = require("../../common/error/errorReporter");
class SnykCodeErrorResponse {
    constructor(error) {
        this.error = error;
    }
}
class SnykCodeErrorHandler extends errorHandler_1.ErrorHandler {
    constructor(contextService, loadingBadge, logger, baseSnykModule, configuration) {
        super();
        this.contextService = contextService;
        this.loadingBadge = loadingBadge;
        this.logger = logger;
        this.baseSnykModule = baseSnykModule;
        this.configuration = configuration;
        this.transientErrors = 0;
        this._connectionRetryLimitExhausted = false;
    }
    resetTransientErrors() {
        this.transientErrors = 0;
    }
    resetRequestId() {
        this._requestId = undefined;
    }
    get connectionRetryLimitExhausted() {
        return this._connectionRetryLimitExhausted;
    }
    isAuthenticationError(errorStatusCode) {
        return errorStatusCode === code_client_1.constants.ErrorCodes.unauthorizedUser;
    }
    isBundleError(error) {
        // checkBundle API call returns 404 sometimes that gets propagated as an Error to us from 'code-client', treat as a transient error [ROAD-683]
        return error instanceof Error && error.message === 'Failed to get remote bundle';
    }
    async authenticationErrorHandler() {
        await this.configuration.setToken('');
        await this.contextService.setContext(views_1.SNYK_CONTEXT.LOGGEDIN, false);
        this.loadingBadge.setLoadingBadge(true);
    }
    static isErrorRetryable(errorStatusCode) {
        switch (errorStatusCode) {
            case code_client_1.constants.ErrorCodes.badGateway:
            case code_client_1.constants.ErrorCodes.serviceUnavailable:
            case code_client_1.constants.ErrorCodes.serverError:
            case code_client_1.constants.ErrorCodes.timeout:
            case code_client_1.constants.ErrorCodes.dnsNotFound:
            case code_client_1.constants.ErrorCodes.connectionRefused:
            case code_client_1.constants.ErrorCodes.notFound:
                return true;
            default:
                return false;
        }
    }
    extractErrorResponse(error) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (!(error instanceof Error) && (error === null || error === void 0 ? void 0 : error.apiName)) {
            // Error can come in different shapes, see https://github.com/snyk/code-client/blob/b5eb140e1400049caf8cbb133a951ab007b031d0/src/http.ts#L43. Extract all.
            const { apiName, statusCode, statusText, errorCode, messages } = error;
            if (errorCode) {
                return new SnykCodeErrorResponse({ apiName, errorCode, messages });
            }
            return new SnykCodeErrorResponse({ apiName, errorCode: statusCode, messages: statusText });
        }
    }
    async processError(error, options = {}, requestId, callback) {
        // We don't want to have unhandled rejections around, so if it
        // happens in the error handler we just log it
        this._requestId = requestId;
        const errorResponse = this.extractErrorResponse(error);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const updatedError = errorResponse ? errorResponse : error;
        return this.processErrorInternal(updatedError, options, callback).catch(err => errorHandler_1.ErrorHandler.handle(err, this.logger, 'Snyk Code error handler failed with error.', {
            [errorReporter_1.TagKeys.CodeRequestId]: this._requestId,
        }));
    }
    async processErrorInternal(error, options = {}, callback) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        const errorStatusCode = (error === null || error === void 0 ? void 0 : error.statusCode) || ((_a = error === null || error === void 0 ? void 0 : error.error) === null || _a === void 0 ? void 0 : _a.errorCode);
        if (this.isAuthenticationError(errorStatusCode)) {
            return await this.authenticationErrorHandler();
        }
        if (SnykCodeErrorHandler.isErrorRetryable(errorStatusCode) || this.isBundleError(error)) {
            return await this.retryHandler(error, errorStatusCode, options, callback);
        }
        this._connectionRetryLimitExhausted = true;
        this.generalErrorHandler(error, options, callback);
        return Promise.resolve();
    }
    generalErrorHandler(error, options, callback) {
        this.transientErrors = 0;
        callback(error);
        this.capture(error, options, { [errorReporter_1.TagKeys.CodeRequestId]: this._requestId });
        this.resetRequestId();
    }
    async retryHandler(error, errorStatusCode, options, callback) {
        this.logger.error(`Connection error to Snyk Code. Try count: ${this.transientErrors + 1}.`);
        if (this.transientErrors > general_1.MAX_CONNECTION_RETRIES) {
            this._connectionRetryLimitExhausted = true;
            this.generalErrorHandler(error, options, callback);
            return;
        }
        this.transientErrors += 1;
        if (errorStatusCode === code_client_1.constants.ErrorCodes.notFound) {
            this.baseSnykModule.snykCodeOld.clearBundle(); // bundle has expired, trigger complete new analysis
        }
        setTimeout(() => {
            this.baseSnykModule.runCodeScan().catch(err => this.capture(err, options));
        }, general_1.CONNECTION_ERROR_RETRY_INTERVAL);
        return Promise.resolve();
    }
    capture(error, options, tags) {
        if (error instanceof SnykCodeErrorResponse) {
            error = new Error(JSON.stringify(error === null || error === void 0 ? void 0 : error.error));
        }
        let msg = error instanceof Error ? error === null || error === void 0 ? void 0 : error.message : '';
        if (Object.keys(options).length > 0) {
            msg += `. ${JSON.stringify(options)}`;
        }
        errorHandler_1.ErrorHandler.handle(error, this.logger, msg, tags);
    }
}
exports.SnykCodeErrorHandler = SnykCodeErrorHandler;
//# sourceMappingURL=snykCodeErrorHandler.js.map