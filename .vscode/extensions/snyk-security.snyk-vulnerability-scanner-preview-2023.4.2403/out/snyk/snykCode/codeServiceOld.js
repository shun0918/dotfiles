"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnykCodeServiceOld = void 0;
const code_client_1 = require("@snyk/code-client");
const uuid_1 = require("uuid");
const statusProvider_1 = require("../common/analysis/statusProvider");
const general_1 = require("../common/constants/general");
const errorHandler_1 = require("../common/error/errorHandler");
const logger_1 = require("../common/logger/logger");
const analysisMessages_1 = require("../common/messages/analysisMessages");
const hover_1 = require("../common/vscode/hover");
const analyzer_1 = __importDefault(require("./analyzer/analyzer"));
const progress_1 = require("./analyzer/progress");
const disposableCodeActionsProvider_1 = require("./codeActions/disposableCodeActionsProvider");
const analysis_1 = require("./messages/analysis");
const error_1 = require("./messages/error");
const issueUtils_1 = require("./utils/issueUtils");
const falsePositiveWebviewProvider_1 = require("./views/falsePositive/falsePositiveWebviewProvider");
const codeSuggestionWebviewProviderOld_1 = require("./views/suggestion/codeSuggestionWebviewProviderOld");
class SnykCodeServiceOld extends statusProvider_1.AnalysisStatusProvider {
    constructor(extensionContext, config, viewManagerService, workspace, window, user, falsePositiveApi, logger, analytics, languages, errorHandler, uriAdapter, codeSettings, learnService, markdownStringAdapter, workspaceTrust) {
        super();
        this.extensionContext = extensionContext;
        this.config = config;
        this.viewManagerService = viewManagerService;
        this.workspace = workspace;
        this.window = window;
        this.user = user;
        this.falsePositiveApi = falsePositiveApi;
        this.logger = logger;
        this.analytics = analytics;
        this.languages = languages;
        this.errorHandler = errorHandler;
        this.uriAdapter = uriAdapter;
        this.learnService = learnService;
        this.markdownStringAdapter = markdownStringAdapter;
        this.workspaceTrust = workspaceTrust;
        this.changedFiles = new Set();
        this._analysisStatus = '';
        this._analysisProgress = '';
        this.temporaryFailed = false;
        this.failed = false;
        this._isAnyWorkspaceFolderTrusted = true;
        this.analyzer = new analyzer_1.default(logger, languages, workspace, analytics, errorHandler, this.uriAdapter, this.config);
        this.registerAnalyzerProviders(this.analyzer);
        this.falsePositiveProvider = new falsePositiveWebviewProvider_1.FalsePositiveWebviewProvider(this, this.window, extensionContext, this.logger, this.analytics);
        this.suggestionProvider = new codeSuggestionWebviewProviderOld_1.CodeSuggestionWebviewProviderOld(config, this.analyzer, window, extensionContext, this.logger, languages, workspace, codeSettings, this.learnService);
        this.progress = new progress_1.Progress(this, viewManagerService, this.workspace);
        this.progress.bindListeners();
    }
    get hasError() {
        return this.failed;
    }
    get hasTransientError() {
        return this.temporaryFailed;
    }
    get isAnyWorkspaceFolderTrusted() {
        return this._isAnyWorkspaceFolderTrusted;
    }
    get analysisStatus() {
        return this._analysisStatus;
    }
    get analysisProgress() {
        return this._analysisProgress;
    }
    async startAnalysis(paths, manualTrigger, reportTriggeredEvent) {
        if (this.isAnalysisRunning || !paths.length) {
            return;
        }
        const enabledFeatures = this.config.getFeaturesConfiguration();
        const requestId = (0, uuid_1.v4)();
        const pathsToTest = this.workspaceTrust.getTrustedFolders(this.config, paths);
        if (!pathsToTest.length) {
            this._isAnyWorkspaceFolderTrusted = false;
            this.viewManagerService.refreshCodeAnalysisViews(enabledFeatures);
            this.logger.info(`Skipping Code scan. ${analysisMessages_1.messages.noWorkspaceTrustDescription}`);
            return;
        }
        this._isAnyWorkspaceFolderTrusted = true;
        try {
            logger_1.Logger.info(analysis_1.messages.started);
            // reset error state
            this.temporaryFailed = false;
            this.failed = false;
            this.reportAnalysisIsTriggered(reportTriggeredEvent, enabledFeatures, manualTrigger);
            this.analysisStarted();
            const snykCodeToken = await this.config.snykCodeToken;
            const analysisContext = {
                analysisContext: {
                    flow: this.config.source,
                    initiator: 'IDE',
                    org: {
                        name: this.config.organization || 'unknown',
                        displayName: 'unknown',
                        publicId: 'unknown',
                        flags: {},
                    },
                },
            };
            let result = null;
            if (this.changedFiles.size && this.remoteBundle) {
                const changedFiles = [...this.changedFiles];
                result = await (0, code_client_1.extendAnalysis)({
                    ...this.remoteBundle,
                    files: changedFiles,
                    connection: this.getConnectionOptions(requestId, snykCodeToken),
                    ...analysisContext,
                });
            }
            else {
                result = await (0, code_client_1.analyzeFolders)({
                    connection: this.getConnectionOptions(requestId, snykCodeToken),
                    analysisOptions: {
                        legacy: true,
                    },
                    fileOptions: {
                        paths: pathsToTest.concat([]),
                    },
                    ...analysisContext,
                });
            }
            if (result) {
                this.remoteBundle = result;
                if (result.analysisResults.type == 'legacy') {
                    this.analyzer.setAnalysisResults(result.analysisResults);
                }
                this.analyzer.createReviewResults();
                logger_1.Logger.info(analysis_1.messages.finished);
                if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeSecurityEnabled) {
                    this.analytics.logAnalysisIsReady({
                        ide: general_1.IDE_NAME,
                        analysisType: 'Snyk Code Security',
                        result: 'Success',
                    });
                }
                if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeQualityEnabled) {
                    this.analytics.logAnalysisIsReady({
                        ide: general_1.IDE_NAME,
                        analysisType: 'Snyk Code Quality',
                        result: 'Success',
                    });
                }
                this.suggestionProvider.checkCurrentSuggestion();
                // cleanup analysis state
                this.changedFiles.clear();
            }
        }
        catch (err) {
            this.temporaryFailed = true;
            await this.errorHandler.processError(err, undefined, requestId, () => {
                this.errorEncountered(requestId);
            });
            if ((enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeSecurityEnabled) && this.errorHandler.connectionRetryLimitExhausted) {
                this.analytics.logAnalysisIsReady({
                    ide: general_1.IDE_NAME,
                    analysisType: 'Snyk Code Security',
                    result: 'Error',
                });
            }
            if ((enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeQualityEnabled) && this.errorHandler.connectionRetryLimitExhausted) {
                this.analytics.logAnalysisIsReady({
                    ide: general_1.IDE_NAME,
                    analysisType: 'Snyk Code Quality',
                    result: 'Error',
                });
            }
        }
        finally {
            this.analysisFinished();
            this.viewManagerService.refreshCodeAnalysisViews(enabledFeatures);
        }
    }
    clearBundle() {
        this.remoteBundle = null;
    }
    reportAnalysisIsTriggered(reportTriggeredEvent, enabledFeatures, manualTrigger) {
        if (reportTriggeredEvent) {
            const analysisType = [];
            if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeSecurityEnabled)
                analysisType.push('Snyk Code Security');
            if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeQualityEnabled)
                analysisType.push('Snyk Code Quality');
            if (analysisType) {
                this.analytics.logAnalysisIsTriggered({
                    analysisType: analysisType,
                    ide: general_1.IDE_NAME,
                    triggeredByUser: manualTrigger,
                });
            }
        }
    }
    updateStatus(status, progress) {
        this._analysisStatus = status;
        this._analysisProgress = progress;
    }
    errorEncountered(requestId) {
        this.temporaryFailed = false;
        this.failed = true;
        this.logger.error(analysis_1.messages.failed(requestId));
    }
    addChangedFile(filePath) {
        this.changedFiles.add(filePath);
    }
    activateWebviewProviders() {
        this.suggestionProvider.activate();
        this.falsePositiveProvider.activate();
    }
    async reportFalsePositive(falsePositive, isSecurityTypeIssue, issueSeverity) {
        try {
            await this.falsePositiveApi.report(falsePositive, this.user);
            this.analytics.logFalsePositiveIsSubmitted({
                issueId: falsePositive.id,
                issueType: issueUtils_1.IssueUtils.getIssueType(isSecurityTypeIssue),
                severity: issueUtils_1.IssueUtils.severityAsText(issueSeverity),
            });
        }
        catch (e) {
            errorHandler_1.ErrorHandler.handle(e, this.logger, error_1.messages.reportFalsePositiveFailed);
        }
    }
    dispose() {
        this.progress.removeAllListeners();
        this.analyzer.dispose();
    }
    getConnectionOptions(requestId, snykCodeToken) {
        if (!snykCodeToken) {
            throw new Error('Snyk token must be filled to obtain connection options');
        }
        return {
            baseURL: this.config.snykCodeBaseURL,
            sessionToken: snykCodeToken,
            source: this.config.source,
            requestId,
            base64Encoding: true,
        };
    }
    registerAnalyzerProviders(analyzer) {
        analyzer.registerHoverProviders(new hover_1.HoverAdapter(), new hover_1.HoverAdapter(), this.markdownStringAdapter);
        analyzer.registerCodeActionProviders(new disposableCodeActionsProvider_1.DisposableCodeActionsProvider(analyzer.codeSecurityReview, {
            findSuggestion: (diagnostic) => analyzer.findSuggestion(diagnostic),
        }, this.analytics), new disposableCodeActionsProvider_1.DisposableCodeActionsProvider(analyzer.codeQualityReview, {
            findSuggestion: (diagnostic) => analyzer.findSuggestion(diagnostic),
        }, this.analytics));
    }
}
exports.SnykCodeServiceOld = SnykCodeServiceOld;
//# sourceMappingURL=codeServiceOld.js.map