"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdvisorService = void 0;
const parsing_1 = require("../../common/parsing");
const moduleParserProvider_1 = require("../../common/services/moduleParserProvider");
const editorDecorator_1 = __importDefault(require("../editor/editorDecorator"));
const SCORE_THRESHOLD = 0.7;
class AdvisorService {
    constructor(window, languages, advisorProvider, logger, workspace, advisorApiClient, themeColorAdapter, hoverAdapter, markdownStringAdapter, configuration) {
        this.window = window;
        this.languages = languages;
        this.advisorProvider = advisorProvider;
        this.logger = logger;
        this.workspace = workspace;
        this.advisorApiClient = advisorApiClient;
        this.themeColorAdapter = themeColorAdapter;
        this.hoverAdapter = hoverAdapter;
        this.markdownStringAdapter = markdownStringAdapter;
        this.configuration = configuration;
        this.disposables = [];
        this.editorDecorator = new editorDecorator_1.default(window, this.languages, this.themeColorAdapter, this.advisorApiClient, this.hoverAdapter, this.markdownStringAdapter);
    }
    async activate() {
        if (!this.configuration.getPreviewFeatures().advisor) {
            return;
        }
        this.activeEditor = this.window.getActiveTextEditor();
        this.registerEditorListeners();
        if (!this.activeEditor) {
            return;
        }
        await this.handleEditorEvent(this.activeEditor.document);
    }
    registerEditorListeners() {
        this.disposables.push(this.workspace.onDidChangeTextDocument(async (ev) => {
            if (ev === null || ev === void 0 ? void 0 : ev.contentChanges.length) {
                this.editorDecorator.resetDecorations(ev.document.fileName);
            }
            await this.handleEditorEvent(ev.document);
        }), this.window.onDidChangeActiveTextEditor(async (ev) => {
            if (!ev) {
                return;
            }
            await this.handleEditorEvent(ev.document);
        }));
    }
    async handleEditorEvent(document) {
        const { fileName, languageId } = document;
        const supportedLanguage = (0, parsing_1.getSupportedLanguage)(fileName, languageId);
        if (document.isDirty || !supportedLanguage) {
            return;
        }
        const modules = this.getModules(fileName, document.getText(), supportedLanguage, this.logger).filter(parsing_1.isValidModuleName);
        const scores = await this.advisorProvider.getScores(modules);
        this.processScores(scores, modules, fileName);
    }
    processScores(scores, modules, fileName) {
        const vulnsLineDecorations = new Map();
        modules.forEach(({ name, line }) => {
            vulnsLineDecorations.set(name, line || -1);
        });
        const decorations = [];
        for (const [packageName, line] of vulnsLineDecorations) {
            if (line < 0) {
                continue;
            }
            const packageScore = scores.find(score => score && score.name === packageName);
            if (!packageScore || packageScore.score >= SCORE_THRESHOLD) {
                continue;
            }
            this.editorDecorator.addScoresDecorations(fileName, packageScore, line, decorations);
        }
    }
    getModules(fileName, source, language, logger) {
        const parser = moduleParserProvider_1.ModuleParserProvider.getInstance(language, logger, this.configuration);
        if (!parser) {
            return [];
        }
        return parser.getModules(fileName, source, language);
    }
    dispose() {
        while (this.disposables.length) {
            const disposable = this.disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
}
exports.AdvisorService = AdvisorService;
//# sourceMappingURL=advisorService.js.map