"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliService = exports.CliError = void 0;
const rxjs_1 = require("rxjs");
const string_argv_1 = __importDefault(require("string-argv"));
const statusProvider_1 = require("../../common/analysis/statusProvider");
const errorHandler_1 = require("../../common/error/errorHandler");
const analysisMessages_1 = require("../../common/messages/analysisMessages");
const cliExecutable_1 = require("../cliExecutable");
const process_1 = require("../process");
class CliError {
    constructor(error, path, isCancellation = false) {
        this.error = error;
        this.path = path;
        this.isCancellation = isCancellation;
    }
}
exports.CliError = CliError;
class CliService extends statusProvider_1.AnalysisStatusProvider {
    constructor(extensionContext, logger, config, workspace, downloadService, languageServer, workspaceTrust) {
        super();
        this.extensionContext = extensionContext;
        this.logger = logger;
        this.config = config;
        this.workspace = workspace;
        this.downloadService = downloadService;
        this.languageServer = languageServer;
        this.workspaceTrust = workspaceTrust;
        this._isAnyWorkspaceFolderTrusted = true;
    }
    get isCliReady() {
        return this._isCliReady;
    }
    get isAnyWorkspaceFolderTrusted() {
        return this._isAnyWorkspaceFolderTrusted;
    }
    async test(manualTrigger, reportTriggeredEvent) {
        this.ensureDependencies();
        const currentCliPath = cliExecutable_1.CliExecutable.getPath(this.extensionContext.extensionPath, this.config.getCliPath());
        const currentCliPathExists = await cliExecutable_1.CliExecutable.exists(this.extensionContext.extensionPath, this.config.getCliPath());
        await this.synchronizeCliPathIfNeeded(currentCliPath, currentCliPathExists);
        if (currentCliPathExists) {
            const cliPath = this.config.getCliPath();
            if (!cliPath) {
                throw new Error('CLI path is not set, probably failed migration.');
            }
            this.logger.info(`Using CLI path ${cliPath}`);
            this.languageServer.cliReady$.next(cliPath);
        }
        // Prevent from CLI scan until Language Server downloads the CLI.
        const cliPath = await (0, rxjs_1.firstValueFrom)(this.languageServer.cliReady$);
        this._isCliReady = true;
        const workspaceFolders = this.workspace.getWorkspaceFolders();
        if (workspaceFolders.length == 0) {
            throw new Error('No workspace was opened.');
        }
        const foldersToTest = this.workspaceTrust.getTrustedFolders(this.config, workspaceFolders);
        if (foldersToTest.length == 0) {
            this.handleNoTrustedFolders();
            this.logger.info(`Skipping Open Source scan. ${analysisMessages_1.messages.noWorkspaceTrustDescription}`);
            return;
        }
        this._isAnyWorkspaceFolderTrusted = true;
        // Start test
        this.analysisStarted();
        this.beforeTest(manualTrigger, reportTriggeredEvent);
        this.result = undefined;
        if (this.cliProcess) {
            const killed = this.cliProcess.kill();
            if (!killed)
                this.logger.error('Failed to kill an already running CLI instance.');
        }
        this.cliProcess = new process_1.CliProcess(this.logger, this.config, this.workspace);
        const args = this.buildArguments(foldersToTest);
        let output;
        try {
            output = await this.cliProcess.spawn(cliPath, foldersToTest[0], args);
        }
        catch (spawnError) {
            if (spawnError instanceof CliError) {
                return spawnError;
            }
            const result = new CliError(spawnError, '');
            this.finalizeTest(result);
            return result;
        }
        const mappedResult = this.mapToResultType(output);
        this.finalizeTest(mappedResult);
        return mappedResult;
    }
    // Synchronizes user configuration with CLI path passed to the Snyk LS.
    // TODO: Remove in VS Code + Language Server feature cleanup.
    async synchronizeCliPathIfNeeded(cliPath, cliPathExists) {
        if (!this.config.getCliPath() && cliPathExists) {
            this.logger.info("Synchronising extension's CLI path with Language Server");
            try {
                await this.config.setCliPath(cliPath);
            }
            catch (e) {
                errorHandler_1.ErrorHandler.handle(e, this.logger, "Failed to synchronize extension's CLI path with Language Server");
            }
        }
        return cliPath;
    }
    handleNoTrustedFolders() {
        this._isAnyWorkspaceFolderTrusted = false;
    }
    buildArguments(foldersToTest) {
        const args = [];
        args.push(...this.command);
        args.push(...foldersToTest);
        args.push('--json');
        const additionalParams = this.config.getAdditionalCliParameters();
        if (additionalParams) {
            args.push(...(0, string_argv_1.default)(additionalParams.trim()));
        }
        return args;
    }
    // To be called to finalise the analysis
    finalizeTest(result) {
        this.result = result;
        this.analysisFinished();
        this.afterTest(result);
    }
}
exports.CliService = CliService;
//# sourceMappingURL=cliService.js.map