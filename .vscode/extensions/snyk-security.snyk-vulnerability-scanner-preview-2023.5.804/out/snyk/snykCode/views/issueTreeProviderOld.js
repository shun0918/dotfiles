"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IssueTreeProviderOld = void 0;
const types_1 = require("../../common/commands/types");
const commands_1 = require("../../common/constants/commands");
const analysisTreeNodeProviderOld_1 = require("../../common/views/analysisTreeNodeProviderOld");
const treeNode_1 = require("../../common/views/treeNode");
const analysis_1 = require("../constants/analysis");
const analysis_2 = require("../messages/analysis");
const analysisUtils_1 = require("../utils/analysisUtils");
class IssueTreeProviderOld extends analysisTreeNodeProviderOld_1.AnalysisTreeNodeProviderOld {
    constructor(contextService, snykCode, diagnosticCollection, configuration) {
        super(configuration, snykCode);
        this.contextService = contextService;
        this.snykCode = snykCode;
        this.diagnosticCollection = diagnosticCollection;
        this.configuration = configuration;
    }
    static getSeverityIcon(severity) {
        return ({
            [analysis_1.SNYK_SEVERITIES.error]: treeNode_1.NODE_ICONS.high,
            [analysis_1.SNYK_SEVERITIES.warning]: treeNode_1.NODE_ICONS.medium,
            [analysis_1.SNYK_SEVERITIES.information]: treeNode_1.NODE_ICONS.low,
        }[severity] || treeNode_1.NODE_ICONS.low);
    }
    static getFileSeverity(counts) {
        for (const s of [analysis_1.SNYK_SEVERITIES.error, analysis_1.SNYK_SEVERITIES.warning, analysis_1.SNYK_SEVERITIES.information]) {
            if (counts[s])
                return s;
        }
        return analysis_1.SNYK_SEVERITIES.information;
    }
    getRootChildren() {
        const review = [];
        let nIssues = 0;
        if (!this.contextService.shouldShowCodeAnalysis)
            return review;
        if (this.snykCode.hasTransientError) {
            return this.getTransientErrorTreeNodes();
        }
        else if (this.snykCode.hasError) {
            return [this.getErrorEncounteredTreeNode()];
        }
        else if (!this.snykCode.isAnyWorkspaceFolderTrusted) {
            return [this.getNoWorkspaceTrustTreeNode()];
        }
        if (this.diagnosticCollection) {
            this.diagnosticCollection.forEach((uri, diagnostics) => {
                const filePath = uri.path.split('/');
                const filename = filePath.pop() || uri.path;
                const dir = filePath.pop();
                nIssues += diagnostics.length;
                if (diagnostics.length == 0)
                    return;
                const [issues, severityCounts] = this.getVulnerabilityTreeNodes(diagnostics, uri);
                issues.sort(this.compareNodes);
                const fileSeverity = IssueTreeProviderOld.getFileSeverity(severityCounts);
                const file = new treeNode_1.TreeNode({
                    text: filename,
                    description: this.getIssueDescriptionText(dir, diagnostics),
                    icon: IssueTreeProviderOld.getSeverityIcon(fileSeverity),
                    children: issues,
                    internal: {
                        nIssues: diagnostics.length,
                        severity: fileSeverity,
                    },
                });
                review.push(file);
            });
        }
        review.sort(this.compareNodes);
        if (this.snykCode.isAnalysisRunning) {
            review.unshift(new treeNode_1.TreeNode({
                text: this.snykCode.analysisStatus,
                description: this.snykCode.analysisProgress,
            }));
        }
        else {
            const topNodes = [
                new treeNode_1.TreeNode({
                    text: this.getIssueFoundText(nIssues),
                }),
                this.getDurationTreeNode(),
                this.getNoSeverityFiltersSelectedTreeNode(),
            ];
            review.unshift(...topNodes.filter((n) => n !== null));
        }
        return review;
    }
    getIssueFoundText(nIssues) {
        return `Snyk found ${!nIssues ? 'no issues! âœ…' : `${nIssues} issue${nIssues === 1 ? '' : 's'}`}`;
    }
    getIssueDescriptionText(dir, diagnostics) {
        return `${dir} - ${diagnostics.length} issue${diagnostics.length === 1 ? '' : 's'}`;
    }
    getFilteredIssues(diagnostics) {
        // Diagnostics are already filtered by the analyzer
        return diagnostics;
    }
    getVulnerabilityTreeNodes(fileVulnerabilities, uri) {
        const severityCounts = {
            [analysis_1.SNYK_SEVERITIES.information]: 0,
            [analysis_1.SNYK_SEVERITIES.warning]: 0,
            [analysis_1.SNYK_SEVERITIES.error]: 0,
        };
        const nodes = fileVulnerabilities.map(d => {
            const severity = (0, analysisUtils_1.getSnykSeverity)(d.severity);
            severityCounts[severity] += 1;
            const params = {
                text: d.message,
                icon: IssueTreeProviderOld.getSeverityIcon(severity),
                issue: {
                    uri,
                    filePath: 'dummy',
                    range: d.range,
                },
                internal: {
                    severity,
                },
                command: {
                    command: commands_1.SNYK_OPEN_ISSUE_COMMAND,
                    title: '',
                    arguments: [
                        {
                            issueType: types_1.OpenCommandIssueType.CodeIssueOld,
                            issue: {
                                message: d.message,
                                filePath: uri,
                                range: d.range,
                                diagnostic: d,
                            },
                        },
                    ],
                },
            };
            return new treeNode_1.TreeNode(params);
        });
        return [nodes, severityCounts];
    }
    getTransientErrorTreeNodes() {
        return [
            new treeNode_1.TreeNode({
                text: analysis_2.messages.temporaryFailed,
                internal: {
                    isError: true,
                },
            }),
            new treeNode_1.TreeNode({
                text: analysis_2.messages.retry,
                internal: {
                    isError: true,
                },
            }),
        ];
    }
}
exports.IssueTreeProviderOld = IssueTreeProviderOld;
//# sourceMappingURL=issueTreeProviderOld.js.map