"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmModuleInfoFetchService = void 0;
const lodash_1 = __importDefault(require("lodash"));
const errorHandler_1 = require("../../../common/error/errorHandler");
/**
 * Responsible for caching & fetching npm module info
 */
class NpmModuleInfoFetchService {
    constructor(config, logger, npmTestApi) {
        this.config = config;
        this.logger = logger;
        this.npmTestApi = npmTestApi;
        this.debounceIntervalInMs = 2000;
        this.debouncedPromises = {};
        this.npmPackageCache = new Map();
        this.vulnerabilityCache = new Map();
    }
    async getModuleVulnerabilityInfo(module) {
        const key = this.getVulnerabilityCacheKey(module);
        if (!key) {
            return { ...module, tested: false };
        }
        const testedModulePromise = this.vulnerabilityCache.get(key);
        if (testedModulePromise === undefined || testedModulePromise instanceof Promise) {
            try {
                const testedModule = await (testedModulePromise || this.lookupVulnerabilities(key, module.string));
                this.vulnerabilityCache.set(key, testedModule);
            }
            catch (e) {
                this.logger.info(`Failed to lookup vulnerabilities for ${key}. ${e}`);
                this.vulnerabilityCache.delete(key);
                return { ...module, tested: false };
            }
        }
        const result = await this.vulnerabilityCache.get(key);
        if (!result) {
            throw new Error(`Vulnerability result isn't available for ${key} due to missing cache entry.`);
        }
        return { ...module, vulnerabilityCount: result.totalVulns, tested: true };
    }
    getVulnerabilityCacheKey(module) {
        try {
            const npmPackage = this.getNpmRegistryPackage(module);
            return `${npmPackage.name}@${npmPackage.version}`;
        }
        catch (e) {
            this.logger.error(errorHandler_1.ErrorHandler.stringifyError(e));
            return undefined;
        }
    }
    getNpmRegistryPackage(module) {
        if (!module.string) {
            throw new Error('Module source string must be provided to work with npm package cache.');
        }
        if (!module.version || !module.name) {
            throw new Error('Module name and version must be provided to fetch a package.');
        }
        const npmPackage = this.npmPackageCache.get(module.string) || { name: module.name, version: module.version };
        this.npmPackageCache.set(module.string, npmPackage);
        return npmPackage;
    }
    lookupVulnerabilities(vulnerabilityKey, npmPackageCacheKey) {
        const npmPackage = this.npmPackageCache.get(npmPackageCacheKey);
        if (!npmPackage) {
            throw new Error('Npm package is not in cache for some reason.');
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return this.debouncePromise(vulnerabilityKey, this.test.bind(this), npmPackage);
    }
    async test(npmPackage) {
        const utm = `utm_medium=${this.config.source}&utm_source=${this.config.source}&utm_campaign=${this.config.source}`;
        const result = await this.npmTestApi.get(`/npm/${npmPackage.name}/${npmPackage.version}?${utm}&type=json`);
        return result.data;
    }
    async debouncePromise(name, fn, ...args) {
        if (!this.debouncedPromises[name]) {
            const debounced = lodash_1.default.debounce((resolve, reject, args) => {
                /* eslint-disable @typescript-eslint/no-unsafe-argument */
                fn(...args)
                    .then(resolve)
                    .catch(reject);
                /* eslint-enable @typescript-eslint/no-unsafe-argument */
            }, this.debounceIntervalInMs);
            this.debouncedPromises[name] = (...args) => new Promise((resolve, reject) => {
                debounced(resolve, reject, args);
            });
        }
        return this.debouncedPromises[name](...args);
    }
}
exports.NpmModuleInfoFetchService = NpmModuleInfoFetchService;
//# sourceMappingURL=npmModuleInfoFetchService.js.map