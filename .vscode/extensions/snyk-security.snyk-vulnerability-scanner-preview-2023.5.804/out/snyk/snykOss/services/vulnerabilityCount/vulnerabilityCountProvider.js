"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleVulnerabilityCountProvider = void 0;
const types_1 = require("../../../common/types");
const ossResult_1 = require("../../ossResult");
class ModuleVulnerabilityCountProvider {
    constructor(ossService, npmModuleInfoFetchService) {
        this.ossService = ossService;
        this.npmModuleInfoFetchService = npmModuleInfoFetchService;
    }
    async getVulnerabilityCount(module, language) {
        const notCalculated = {
            name: module.name,
            fileName: module.fileName,
            line: null,
            range: null,
            hasCount: false,
        };
        if ([types_1.Language.TypeScript, types_1.Language.JavaScript, types_1.Language.PJSON].includes(language)) {
            const ossResult = this.ossService.getResultArray();
            if (!ossResult) {
                return notCalculated;
            }
            return this.mapOssResult(module, ossResult);
        }
        else if (language == types_1.Language.HTML) {
            const testedModuleInfo = await this.npmModuleInfoFetchService.getModuleVulnerabilityInfo(module);
            return this.mapTestedImportedModule(testedModuleInfo);
        }
        return notCalculated;
    }
    isFilePartOfOssTest(filePath, ossFileResult) {
        if ((0, ossResult_1.isResultCliError)(ossFileResult)) {
            return false;
        }
        // File is considered to be part of OSS test if it has common root directory between OSS result path and filename path.
        // This is since package.json always lies in the root directory folder of a project.
        if (filePath.startsWith(ossFileResult.path)) {
            return true;
        }
        return false;
    }
    mapTestedImportedModule(module) {
        return {
            name: module.name,
            version: module.version,
            fileName: module.fileName,
            line: module.line,
            range: module.loc,
            count: module.vulnerabilityCount,
            hasCount: module.tested,
        };
    }
    mapOssResult(module, ossResult) {
        const notCalculated = {
            name: module.name,
            fileName: module.fileName,
            line: null,
            hasCount: false,
            range: null,
        };
        for (const fileResult of ossResult) {
            if (!this.isFilePartOfOssTest(module.fileName, fileResult)) {
                continue;
            }
            const vulnerabilities = this.ossService.getUniqueVulnerabilities(fileResult.vulnerabilities);
            // Sum up all vulnerabilities detected in first-level dependencies by OSS matching the imported module name.
            // Ideally we want to use the same mechanism as NPM for determining the version used within users code. For now we stick with direct-vulnerability surfacing only.
            const directVulnerabilities = vulnerabilities
                .filter(v => v.name === module.name)
                .filter(v => v.from.length == 2 && v.from[1].startsWith(module.name));
            const vulnerabilityCount = directVulnerabilities.length;
            // NPM allows declaration of the same direct dependency with multiple versions of it (e.g. {"dependencies": "webpack": "^4.44.1", "webpack": "^4.44.2",}). Thus, we should account for vulnerabilities that can be in different versions of the same package.
            const hasSingleVersionVulnerability = directVulnerabilities.every(vuln => vuln.version == directVulnerabilities[0].version);
            let moduleVersion;
            if (directVulnerabilities.length && hasSingleVersionVulnerability) {
                moduleVersion = directVulnerabilities[0].version;
            }
            const severityCounts = this.getSeverityCounts(directVulnerabilities);
            const mostSevereVulnerability = this.getMostSevereVulnerability(directVulnerabilities);
            return {
                name: module.name,
                version: moduleVersion,
                fileName: module.fileName,
                count: vulnerabilityCount,
                line: module.line,
                range: module.loc,
                hasCount: vulnerabilityCount > 0,
                severityCounts,
                mostSevereVulnerabilityId: mostSevereVulnerability === null || mostSevereVulnerability === void 0 ? void 0 : mostSevereVulnerability.id,
            };
        }
        return notCalculated;
    }
    getSeverityCounts(directVulnerabilities) {
        return directVulnerabilities
            .map(v => v.severity)
            .reduce((arr, severity) => ({ ...arr, [severity]: directVulnerabilities.filter(v => v.severity == severity).length }), {});
    }
    getMostSevereVulnerability(vulnerabilities) {
        var _a;
        return (_a = vulnerabilities.sort((a, b) => {
            if (!a.cvssScore && !b.cvssScore)
                return 0;
            if (!a.cvssScore)
                return 1;
            if (!b.cvssScore)
                return -1;
            const cvssScore1 = parseFloat(a.cvssScore);
            const cvssScore2 = parseFloat(b.cvssScore);
            if (cvssScore1 > cvssScore2) {
                return -1;
            }
            else if (cvssScore1 < cvssScore2) {
                return 1;
            }
            return 0;
        })) === null || _a === void 0 ? void 0 : _a[0];
    }
}
exports.ModuleVulnerabilityCountProvider = ModuleVulnerabilityCountProvider;
//# sourceMappingURL=vulnerabilityCountProvider.js.map