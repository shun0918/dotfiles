"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OssService = void 0;
const marked = __importStar(require("marked"));
const rxjs_1 = require("rxjs");
const cliService_1 = require("../../cli/services/cliService");
const general_1 = require("../../common/constants/general");
const test_1 = require("../messages/test");
const ossResult_1 = require("../ossResult");
const manifestFileWatcher_1 = __importDefault(require("../watchers/manifestFileWatcher"));
class OssService extends cliService_1.CliService {
    constructor(extensionContext, logger, config, suggestionProvider, workspace, viewManagerService, downloadService, dailyScanJob, notificationService, analytics, languageServer, workspaceTrust) {
        super(extensionContext, logger, config, workspace, downloadService, languageServer, workspaceTrust);
        this.extensionContext = extensionContext;
        this.logger = logger;
        this.config = config;
        this.suggestionProvider = suggestionProvider;
        this.workspace = workspace;
        this.viewManagerService = viewManagerService;
        this.downloadService = downloadService;
        this.dailyScanJob = dailyScanJob;
        this.notificationService = notificationService;
        this.analytics = analytics;
        this.languageServer = languageServer;
        this.workspaceTrust = workspaceTrust;
        this.command = ['test'];
        this.isVulnerabilityTreeVisible = false;
        this.scanFinished$ = new rxjs_1.Subject();
        this.getResultArray = () => {
            if (!this.result) {
                return undefined;
            }
            return Array.isArray(this.result) ? this.result : [this.result];
        };
    }
    mapToResultType(rawCliResult) {
        if (rawCliResult.length == 0) {
            throw new Error('CLI returned empty output result.');
        }
        let result;
        try {
            result = JSON.parse(rawCliResult);
        }
        catch (err) {
            throw new Error(`Failed to parse JSON result. Unparsed: ${rawCliResult}`);
        }
        return result;
    }
    ensureDependencies() {
        this.viewManagerService.refreshOssView();
        this.logger.info('Waiting for Open Source scan CLI readiness');
    }
    beforeTest(manualTrigger, reportTriggeredEvent) {
        this.logger.info(test_1.messages.testStarted);
        this.viewManagerService.refreshOssView();
        if (reportTriggeredEvent) {
            this.analytics.logAnalysisIsTriggered({
                analysisType: ['Snyk Open Source'],
                ide: general_1.IDE_NAME,
                triggeredByUser: manualTrigger,
            });
        }
    }
    afterTest(result) {
        if (result instanceof cliService_1.CliError) {
            this.logger.error(`${test_1.messages.testFailed} ${result.error}`);
            this.logAnalysisIsReady('Error');
        }
        else {
            this.logOssResult(result);
            if (this.config.shouldAutoScanOss) {
                this.dailyScanJob.schedule();
            }
        }
        this.scanFinished$.next();
        this.viewManagerService.refreshOssView();
    }
    handleLsDownloadFailure() {
        super.handleLsDownloadFailure();
        this.viewManagerService.refreshOssView();
    }
    handleNoTrustedFolders() {
        super.handleNoTrustedFolders();
        this.viewManagerService.refreshOssView();
    }
    activateSuggestionProvider() {
        this.suggestionProvider.activate();
    }
    showSuggestionProvider(vulnerability) {
        return this.suggestionProvider.showPanel(vulnerability);
    }
    activateManifestFileWatcher(extension) {
        const manifestWatcher = (0, manifestFileWatcher_1.default)(extension, this.workspace, this.config);
        this.extensionContext.addDisposables(manifestWatcher);
    }
    setVulnerabilityTreeVisibility(visible) {
        this.isVulnerabilityTreeVisible = visible;
    }
    getUniqueVulnerabilities(vulnerabilities) {
        return vulnerabilities.filter((val, i, arr) => arr.findIndex(el => el.id === val.id) == i);
    }
    getNewCriticalVulnerabilitiesCount(currentResult, otherResult) {
        if (Array.isArray(currentResult) && Array.isArray(otherResult)) {
            let newVulnerabilityCount = 0;
            for (let i = 0; i < otherResult.length; i++) {
                newVulnerabilityCount += this.getNewCriticalVulnerabilitiesCount(currentResult[i], otherResult[i]);
            }
            return newVulnerabilityCount;
        }
        // if only one of results is an array, no count possible
        if (Array.isArray(currentResult) || Array.isArray(otherResult)) {
            throw new Error('Result types mismatch for new vulnerabilities calculation.');
        }
        if (!currentResult || (0, ossResult_1.isResultCliError)(currentResult)) {
            return 0;
        }
        const currentVulnSet = this.getUniqueVulnerabilities(currentResult.vulnerabilities).filter(v => v.severity === ossResult_1.OssSeverity.Critical);
        if ((0, ossResult_1.isResultCliError)(otherResult)) {
            return currentVulnSet.length;
        }
        const otherVulnSet = this.getUniqueVulnerabilities(otherResult.vulnerabilities).filter(v => v.severity === ossResult_1.OssSeverity.Critical);
        if (currentVulnSet.length > otherVulnSet.length) {
            return currentVulnSet.length - otherVulnSet.length;
        }
        return 0;
    }
    getOssIssueCommandArg(vulnerability, allVulnerabilities) {
        return new Promise((resolve, reject) => {
            const matchingIdVulnerabilities = allVulnerabilities.filter(v => v.id === vulnerability.id);
            marked.parse(vulnerability.description, (err, overviewHtml) => {
                if (err) {
                    return reject(err);
                }
                return resolve({
                    ...vulnerability,
                    matchingIdVulnerabilities: matchingIdVulnerabilities,
                    overviewHtml,
                });
            });
        });
    }
    logOssResult(result) {
        const fileResults = Array.isArray(result) ? result : [result];
        for (const fileResult of fileResults) {
            if ((0, ossResult_1.isResultCliError)(fileResult)) {
                this.logger.error(this.getTestErrorMessage(fileResult));
                this.logAnalysisIsReady('Error');
            }
            else {
                this.logger.info(test_1.messages.testFinished(fileResult.projectName));
                this.logAnalysisIsReady('Success');
            }
        }
    }
    getTestErrorMessage(fileResult) {
        let errorMessage;
        if (fileResult.path) {
            errorMessage = `${test_1.messages.testFailedForPath(fileResult.path)} ${fileResult.error}`;
        }
        else {
            errorMessage = `${test_1.messages.testFailed} ${fileResult.error}`;
        }
        return errorMessage;
    }
    logAnalysisIsReady(result) {
        this.analytics.logAnalysisIsReady({
            ide: general_1.IDE_NAME,
            analysisType: 'Snyk Open Source',
            result,
        });
    }
}
exports.OssService = OssService;
//# sourceMappingURL=ossService.js.map