"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const rxjs_1 = require("rxjs");
const cliService_1 = require("../../cli/services/cliService");
const instance_1 = require("../../common/configuration/instance");
const general_1 = require("../../common/constants/general");
const views_1 = require("../../common/constants/views");
const errorHandler_1 = require("../../common/error/errorHandler");
const experimentService_1 = require("../../common/experiment/services/experimentService");
const logger_1 = require("../../common/logger/logger");
const workspace_1 = require("../../common/vscode/workspace");
const baseSnykModule_1 = __importDefault(require("./baseSnykModule"));
class SnykLib extends baseSnykModule_1.default {
    constructor() {
        super(...arguments);
        // This function is called by commands, error handlers, etc.
        // We should avoid having duplicate parallel executions.
        this.runScan = _.debounce(this.runFullScan_.bind(this), general_1.DEFAULT_SCAN_DEBOUNCE_INTERVAL, { leading: true });
        this.runCodeScan = _.debounce(this.startSnykCodeAnalysis.bind(this), general_1.DEFAULT_SCAN_DEBOUNCE_INTERVAL, {
            leading: true,
        });
        this.runOssScan = _.debounce(this.startOssAnalysis.bind(this), general_1.OSS_SCAN_DEBOUNCE_INTERVAL, { leading: true });
    }
    async runFullScan_(manual = false) {
        logger_1.Logger.info('Starting full scan');
        await this.contextService.setContext(views_1.SNYK_CONTEXT.ERROR, false);
        this.snykCodeErrorHandler.resetTransientErrors();
        this.loadingBadge.setLoadingBadge(false);
        const token = await instance_1.configuration.getToken();
        try {
            if (!token) {
                return;
            }
            await this.contextService.setContext(views_1.SNYK_CONTEXT.AUTHENTICATING, false);
            await this.contextService.setContext(views_1.SNYK_CONTEXT.LOGGEDIN, true);
            if (!instance_1.configuration.getFeaturesConfiguration()) {
                await this.contextService.setContext(views_1.SNYK_CONTEXT.FEATURES_SELECTED, false);
                return;
            }
            await this.contextService.setContext(views_1.SNYK_CONTEXT.FEATURES_SELECTED, true);
            const workspacePaths = workspace_1.vsCodeWorkspace.getWorkspaceFolders();
            await this.setWorkspaceContext(workspacePaths);
            await this.user.identify(this.snykApiClient, this.analytics);
            if (workspacePaths.length) {
                this.logFullAnalysisIsTriggered(manual);
                void this.startOssAnalysis(manual, false);
                await this.startSnykCodeAnalysis(workspacePaths, manual, false); // mark void, handle errors inside of startSnykCodeAnalysis()
            }
        }
        catch (err) {
            await errorHandler_1.ErrorHandler.handleGlobal(err, logger_1.Logger, this.contextService, this.loadingBadge);
        }
    }
    async enableCode() {
        const wasEnabled = await this.codeSettings.enable();
        if (wasEnabled) {
            await this.codeSettings.checkCodeEnabled();
            logger_1.Logger.info('Snyk Code was enabled.');
            try {
                await this.startSnykCodeAnalysis();
            }
            catch (err) {
                errorHandler_1.ErrorHandler.handle(err, logger_1.Logger);
            }
        }
    }
    async startSnykCodeAnalysis(paths = [], manual = false, reportTriggeredEvent = true) {
        var _a, _b;
        // If the execution is suspended, we only allow user-triggered Snyk Code analyses.
        if (this.isSnykCodeAutoscanSuspended(manual)) {
            return;
        }
        const codeEnabled = await this.codeSettings.checkCodeEnabled();
        if (!codeEnabled) {
            return;
        }
        // if LS is used to scan, don't proceed
        const codeScansViaLs = await this.experimentService.isUserPartOfExperiment(experimentService_1.ExperimentKey.CodeScansViaLanguageServer);
        if (codeScansViaLs) {
            return;
        }
        if (!((_a = instance_1.configuration.getFeaturesConfiguration()) === null || _a === void 0 ? void 0 : _a.codeSecurityEnabled) &&
            !((_b = instance_1.configuration.getFeaturesConfiguration()) === null || _b === void 0 ? void 0 : _b.codeQualityEnabled)) {
            return;
        }
        if (!paths.length) {
            paths = workspace_1.vsCodeWorkspace.getWorkspaceFolders();
        }
        await this.snykCodeOld.startAnalysis(paths, manual, reportTriggeredEvent);
    }
    async onDidChangeWelcomeViewVisibility(visible) {
        if (visible && !(await instance_1.configuration.getToken())) {
            // Track if a user is not authenticated and expanded the analysis view
            this.analytics.logWelcomeViewIsViewed();
        }
    }
    onDidChangeOssTreeVisibility(visible) {
        if (this.ossService) {
            this.ossService.setVulnerabilityTreeVisibility(visible);
        }
    }
    async checkAdvancedMode() {
        await this.contextService.setContext(views_1.SNYK_CONTEXT.ADVANCED, instance_1.configuration.shouldShowAdvancedView);
    }
    async setWorkspaceContext(workspacePaths) {
        const workspaceFound = !!workspacePaths.length;
        await this.contextService.setContext(views_1.SNYK_CONTEXT.WORKSPACE_FOUND, workspaceFound);
    }
    async startOssAnalysis(manual = false, reportTriggeredEvent = true) {
        var _a;
        if (!((_a = instance_1.configuration.getFeaturesConfiguration()) === null || _a === void 0 ? void 0 : _a.ossEnabled))
            return;
        if (!this.ossService)
            throw new Error('OSS service is not initialized.');
        // wait until Snyk Language Server is downloaded
        await (0, rxjs_1.firstValueFrom)(this.downloadService.downloadReady$);
        try {
            const result = await this.ossService.test(manual, reportTriggeredEvent);
            if (result instanceof cliService_1.CliError || !result) {
                return;
            }
        }
        catch (err) {
            // catch unhandled error cases by reporting test failure
            this.ossService.finalizeTest(new cliService_1.CliError(err));
        }
    }
    isSnykCodeAutoscanSuspended(manual) {
        return !manual && !this.scanModeService.isCodeAutoScanAllowed();
    }
    logFullAnalysisIsTriggered(manual) {
        const analysisType = [];
        const enabledFeatures = instance_1.configuration.getFeaturesConfiguration();
        // Ensure preconditions are the same as within running specific analysis
        if (!this.isSnykCodeAutoscanSuspended(manual)) {
            if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeSecurityEnabled)
                analysisType.push('Snyk Code Security');
            if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.codeQualityEnabled)
                analysisType.push('Snyk Code Quality');
        }
        if (enabledFeatures === null || enabledFeatures === void 0 ? void 0 : enabledFeatures.ossEnabled)
            analysisType.push('Snyk Open Source');
        if (analysisType.length) {
            this.analytics.logAnalysisIsTriggered({
                analysisType: analysisType,
                ide: general_1.IDE_NAME,
                triggeredByUser: manual,
            });
        }
    }
}
exports.default = SnykLib;
//# sourceMappingURL=snykLib.js.map