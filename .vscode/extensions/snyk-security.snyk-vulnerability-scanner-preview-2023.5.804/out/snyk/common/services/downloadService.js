"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadService = void 0;
const rxjs_1 = require("rxjs");
const checksum_1 = require("../../cli/checksum");
const messages_1 = require("../../cli/messages/messages");
const globalState_1 = require("../constants/globalState");
const languageServer_1 = require("../constants/languageServer");
const downloader_1 = require("../download/downloader");
const lsExecutable_1 = require("../languageServer/lsExecutable");
class DownloadService {
    constructor(extensionContext, configuration, lsApi, window, logger, downloader) {
        this.extensionContext = extensionContext;
        this.configuration = configuration;
        this.lsApi = lsApi;
        this.window = window;
        this.logger = logger;
        this.fourDaysInMs = 4 * 24 * 3600 * 1000;
        this.downloadReady$ = new rxjs_1.ReplaySubject(1);
        this.downloader = downloader !== null && downloader !== void 0 ? downloader : new downloader_1.Downloader(configuration, lsApi, window, logger);
    }
    async downloadOrUpdate() {
        const lsInstalled = await this.isLsInstalled();
        if (!this.configuration.isAutomaticDependencyManagementEnabled()) {
            this.downloadReady$.next();
            return false;
        }
        if (!lsInstalled) {
            const downloaded = await this.download();
            this.downloadReady$.next();
            return downloaded;
        }
        const updated = await this.update();
        this.downloadReady$.next();
        return updated;
    }
    async download() {
        this.logger.info(messages_1.messages.startingDownload);
        const executable = await this.downloader.download();
        if (!executable) {
            return false;
        }
        await this.setLastLsUpdateDateAndChecksum(executable.checksum);
        await this.setCurrentLspVersion();
        this.logger.info(messages_1.messages.downloadFinished(executable.version));
        return true;
    }
    async update() {
        // let language server manage CLI downloads, but download LS here
        const platform = lsExecutable_1.LsExecutable.getCurrentWithArch();
        const lsInstalled = await this.isLsInstalled();
        const lspVersionHasUpdated = this.hasLspVersionUpdated();
        const needsUpdate = this.isFourDaysPassedSinceLastLsUpdate() || lspVersionHasUpdated;
        if (!lsInstalled || needsUpdate) {
            const updateAvailable = await this.isLsUpdateAvailable(platform);
            if (!updateAvailable) {
                return false;
            }
            const executable = await this.downloader.download();
            if (!executable) {
                return false;
            }
            await this.setLastLsUpdateDateAndChecksum(executable.checksum);
            await this.setCurrentLspVersion();
            this.logger.info(messages_1.messages.downloadFinished(executable.version));
            return true;
        }
        return false;
    }
    async isLsInstalled() {
        const lsExecutableExists = await lsExecutable_1.LsExecutable.exists(this.configuration);
        const lastUpdateDateWritten = !!this.getLastLsUpdateDate();
        const lsChecksumWritten = !!this.getLsChecksum();
        return lsExecutableExists && lastUpdateDateWritten && lsChecksumWritten;
    }
    async isLsUpdateAvailable(platform) {
        const latestChecksum = await this.lsApi.getSha256Checksum(platform);
        const path = lsExecutable_1.LsExecutable.getPath(this.configuration.getSnykLanguageServerPath());
        // Update is available if fetched checksum not matching the current one
        const checksum = await checksum_1.Checksum.getChecksumOf(path, latestChecksum);
        if (checksum.verify()) {
            this.logger.info(messages_1.messages.isLatest);
            return false;
        }
        return true;
    }
    async setLastLsUpdateDateAndChecksum(checksum) {
        await this.extensionContext.updateGlobalStateValue(globalState_1.MEMENTO_LS_LAST_UPDATE_DATE, Date.now());
        await this.extensionContext.updateGlobalStateValue(globalState_1.MEMENTO_LS_CHECKSUM, checksum.checksum);
    }
    async setCurrentLspVersion() {
        await this.extensionContext.updateGlobalStateValue(globalState_1.MEMENTO_LS_PROTOCOL_VERSION, languageServer_1.PROTOCOL_VERSION);
    }
    isFourDaysPassedSinceLastLsUpdate() {
        const lastUpdateDate = this.getLastLsUpdateDate();
        if (!lastUpdateDate) {
            throw new Error('Last update date is not known.');
        }
        return Date.now() - lastUpdateDate > this.fourDaysInMs;
    }
    hasLspVersionUpdated() {
        const currentProtoclVersion = this.getLsProtocolVersion();
        return currentProtoclVersion != languageServer_1.PROTOCOL_VERSION;
    }
    getLastLsUpdateDate() {
        return this.extensionContext.getGlobalStateValue(globalState_1.MEMENTO_LS_LAST_UPDATE_DATE);
    }
    getLsProtocolVersion() {
        return this.extensionContext.getGlobalStateValue(globalState_1.MEMENTO_LS_PROTOCOL_VERSION);
    }
    getLsChecksum() {
        return this.extensionContext.getGlobalStateValue(globalState_1.MEMENTO_LS_CHECKSUM);
    }
}
exports.DownloadService = DownloadService;
//# sourceMappingURL=downloadService.js.map