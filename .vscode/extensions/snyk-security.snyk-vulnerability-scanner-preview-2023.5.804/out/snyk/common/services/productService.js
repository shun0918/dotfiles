"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductService = void 0;
const statusProvider_1 = require("../analysis/statusProvider");
const types_1 = require("../languageServer/types");
class ProductService extends statusProvider_1.AnalysisStatusProvider {
    constructor(extensionContext, config, suggestionProvider, viewManagerService, workspace, workspaceTrust, languageServer, languages, logger) {
        super();
        this.extensionContext = extensionContext;
        this.config = config;
        this.suggestionProvider = suggestionProvider;
        this.viewManagerService = viewManagerService;
        this.workspace = workspace;
        this.workspaceTrust = workspaceTrust;
        this.languageServer = languageServer;
        this.languages = languages;
        this.logger = logger;
        // Track running scan count. Assumption: server sends N success/error messages for N scans in progress.
        this.runningScanCount = 0;
        this.disposables = [];
        this._result = new Map();
        this.lsSubscription = this.subscribeToLsScanMessages();
    }
    registerCodeActionsProvider(provider) {
        this.languages.registerCodeActionsProvider({ scheme: 'file', language: '*' }, provider);
    }
    getIssue(folderPath, issueId) {
        const folderResult = this._result.get(folderPath);
        if (folderResult instanceof Error) {
            return undefined;
        }
        return folderResult === null || folderResult === void 0 ? void 0 : folderResult.find(issue => issue.id === issueId);
    }
    getIssueById(issueId) {
        const results = this._result.values();
        for (const folderResult of results) {
            if (folderResult instanceof Error) {
                return undefined;
            }
            const issue = folderResult === null || folderResult === void 0 ? void 0 : folderResult.find(issue => issue.id === issueId);
            if (issue) {
                return issue;
            }
        }
        return undefined;
    }
    get result() {
        return this._result;
    }
    get isAnyWorkspaceFolderTrusted() {
        const workspacePaths = this.workspace.getWorkspaceFolders();
        return this.workspaceTrust.getTrustedFolders(this.config, workspacePaths).length > 0;
    }
    resetResult(folderPath) {
        this._result.delete(folderPath);
        this.refreshTreeView();
    }
    isAnyResultAvailable() {
        return this._result.size > 0;
    }
    activateWebviewProviders() {
        this.suggestionProvider.activate();
    }
    showSuggestionProvider(folderPath, issueId) {
        const issue = this.getIssue(folderPath, issueId);
        if (!issue) {
            this.logger.error(`Failed to find issue with id ${issueId} to open a details panel.`);
            return Promise.resolve();
        }
        return this.suggestionProvider.showPanel(issue);
    }
    disposeSuggestionPanelIfStale() {
        const openIssueId = this.suggestionProvider.openIssueId;
        if (!openIssueId)
            return;
        const found = this.getIssueById(openIssueId);
        if (!found)
            this.suggestionProvider.disposePanel();
    }
    handleLsDownloadFailure() {
        super.handleLsDownloadFailure();
        this.refreshTreeView();
    }
    dispose() {
        this.lsSubscription.unsubscribe();
    }
    // Must be called from the child class to listen on scan messages
    handleLsScanMessage(scanMsg) {
        if (scanMsg.status == types_1.ScanStatus.InProgress) {
            if (!this.isAnalysisRunning) {
                this.analysisStarted();
                this._result.set(scanMsg.folderPath, []);
                this.refreshTreeView();
            }
            this.runningScanCount++;
            return;
        }
        if (scanMsg.status == types_1.ScanStatus.Success || scanMsg.status == types_1.ScanStatus.Error) {
            this.handleSuccessOrError(scanMsg);
            this.disposeSuggestionPanelIfStale();
        }
    }
    handleSuccessOrError(scanMsg) {
        this.runningScanCount--;
        if (scanMsg.status == types_1.ScanStatus.Success) {
            this._result.set(scanMsg.folderPath, scanMsg.issues);
        }
        else {
            this._result.set(scanMsg.folderPath, new Error('Failed to analyze.'));
        }
        if (this.runningScanCount <= 0) {
            this.analysisFinished();
            this.runningScanCount = 0;
            this.refreshTreeView();
        }
    }
}
exports.ProductService = ProductService;
//# sourceMappingURL=productService.js.map