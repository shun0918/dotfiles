"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeScanOrchestrator = void 0;
const views_1 = require("../../constants/views");
const experimentService_1 = require("../../experiment/services/experimentService");
const types_1 = require("../types");
class CodeScanOrchestrator {
    constructor(experimentService, languageServer, logger, contextService, extension) {
        this.experimentService = experimentService;
        this.languageServer = languageServer;
        this.logger = logger;
        this.contextService = contextService;
        this.extension = extension;
        this.lastExperimentCheck = new Date().getTime();
        this.setWaitTimeInMs(1000 * 60 * 15); // 15 minutes
        this.lsSubscription = languageServer.scan$.subscribe(
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        async (scan) => await this.handleExperimentCheck(scan));
    }
    dispose() {
        this.lsSubscription.unsubscribe();
    }
    async handleExperimentCheck(scan) {
        if (!this.isCheckRequired() || scan.status !== types_1.ScanStatus.InProgress || scan.product !== types_1.ScanProduct.Code) {
            this.logger.debug('Code scan update not required.');
            return;
        }
        if (!this.contextService.isCodeInLsPreview) {
            return;
        }
        // check if the user is part of the experiment
        const isPartOfLSCodeExperiment = await this.experimentService.isUserPartOfExperiment(experimentService_1.ExperimentKey.CodeScansViaLanguageServer, true);
        if (!isPartOfLSCodeExperiment) {
            await this.contextService.setContext(views_1.SNYK_CONTEXT.LS_CODE_PREVIEW, false);
            await this.extension.runCodeScan();
            await this.extension.restartLanguageServer();
        }
        // update lastExperimentCheckTime
        this.lastExperimentCheck = new Date().getTime();
    }
    setWaitTimeInMs(ms) {
        this.waitTimeInMs = ms;
    }
    isCheckRequired() {
        const currentTimestamp = new Date().getTime();
        return currentTimestamp - this.lastExperimentCheck > this.waitTimeInMs;
    }
}
exports.CodeScanOrchestrator = CodeScanOrchestrator;
//# sourceMappingURL=codeScanOrchestrator.js.map