"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBundleFromFolders = exports.remoteBundleFactory = exports.uploadRemoteBundle = void 0;
/* eslint-disable no-await-in-loop */
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const p_map_1 = __importDefault(require("p-map"));
const files_1 = require("./files");
const http_1 = require("./http");
const constants_1 = require("./constants");
const emitter_1 = require("./emitter");
async function* prepareRemoteBundle(options) {
    let response;
    let { bundleHash } = options;
    let cumulativeProgress = 0;
    emitter_1.emitter.createBundleProgress(cumulativeProgress, options.files.length);
    for (const chunkedFiles of (0, files_1.composeFilePayloads)(options.files, constants_1.MAX_PAYLOAD)) {
        const apiParams = {
            ...(0, lodash_pick_1.default)(options, ['baseURL', 'sessionToken', 'source', 'removedFiles', 'requestId', 'base64Encoding']),
            files: chunkedFiles.reduce((d, f) => {
                // deepcode ignore PrototypePollution: FP this is an internal code
                d[f.bundlePath] = f.hash;
                return d;
            }, {}),
        };
        if (!bundleHash) {
            // eslint-disable-next-line no-await-in-loop
            response = await (0, http_1.createBundle)(apiParams);
        }
        else {
            // eslint-disable-next-line no-await-in-loop
            response = await (0, http_1.extendBundle)({ bundleHash, ...apiParams });
        }
        cumulativeProgress += chunkedFiles.length;
        emitter_1.emitter.createBundleProgress(cumulativeProgress, options.files.length);
        if (response.type === 'error') {
            // TODO: process Error
            yield response;
            break;
        }
        bundleHash = response.value.bundleHash;
        yield response;
    }
}
/**
 * Splits files in buckets and upload in parallel
 * @param baseURL
 * @param sessionToken
 * @param remoteBundle
 */
async function uploadRemoteBundle(options) {
    let uploadedFiles = 0;
    emitter_1.emitter.uploadBundleProgress(0, options.files.length);
    const apiParams = (0, lodash_pick_1.default)(options, ['baseURL', 'sessionToken', 'source', 'bundleHash', 'requestId', 'base64Encoding']);
    const uploadFileChunks = async (bucketFiles) => {
        // Note: we specifically create __new__ isolated bundles here to faster files upload
        const resp = await (0, http_1.createBundle)({
            ...apiParams,
            files: bucketFiles.reduce((d, f) => {
                d[f.bundlePath] = (0, lodash_pick_1.default)(f, ['hash', 'content']);
                return d;
            }, {}),
        });
        if (resp.type !== 'error') {
            uploadedFiles += bucketFiles.length;
            emitter_1.emitter.uploadBundleProgress(uploadedFiles, options.files.length);
        }
    };
    const files = [];
    for (const bucketFiles of (0, files_1.composeFilePayloads)(options.files, constants_1.MAX_PAYLOAD)) {
        files.push(bucketFiles);
    }
    await (0, p_map_1.default)(files, async (task) => await uploadFileChunks(task), {
        concurrency: constants_1.UPLOAD_CONCURRENCY,
    });
}
exports.uploadRemoteBundle = uploadRemoteBundle;
async function fullfillRemoteBundle(options) {
    // Fulfill remote bundle by uploading only missing files (splitted in chunks)
    // Check remove bundle to make sure no missing files left
    let attempts = 0;
    let { remoteBundle } = options;
    const connectionOptions = (0, lodash_pick_1.default)(options, ['baseURL', 'sessionToken', 'source', 'requestId', 'base64Encoding']);
    while (remoteBundle.missingFiles.length && attempts < (options.maxAttempts || constants_1.MAX_UPLOAD_ATTEMPTS)) {
        const missingFiles = await (0, files_1.resolveBundleFiles)(options.baseDir, remoteBundle.missingFiles);
        await uploadRemoteBundle({
            ...connectionOptions,
            bundleHash: remoteBundle.bundleHash,
            files: missingFiles,
        });
        const bundleResponse = await (0, http_1.checkBundle)({ ...connectionOptions, bundleHash: remoteBundle.bundleHash });
        if (bundleResponse.type === 'error') {
            throw new Error('Failed to get remote bundle');
        }
        // eslint-disable-next-line no-param-reassign
        remoteBundle = bundleResponse.value;
        attempts += 1;
    }
    return remoteBundle;
}
async function remoteBundleFactory(options) {
    let remoteBundle = null;
    const baseOptions = (0, lodash_pick_1.default)(options, ['baseURL', 'sessionToken', 'source', 'baseDir', 'requestId', 'base64Encoding']);
    const bundleFactory = prepareRemoteBundle((0, lodash_omit_1.default)(options, ['baseDir']));
    for await (const response of bundleFactory) {
        if (response.type === 'error') {
            throw response.error;
        }
        remoteBundle = await fullfillRemoteBundle({ ...baseOptions, remoteBundle: response.value });
        if (remoteBundle.missingFiles.length) {
            throw new Error(`Failed to upload # files: ${remoteBundle.missingFiles.length}`);
        }
    }
    return remoteBundle;
}
exports.remoteBundleFactory = remoteBundleFactory;
/**
 * Get supported filters and test baseURL for correctness and availability
 *
 * @param baseURL
 * @param source
 * @returns
 */
async function getSupportedFiles(baseURL, source, requestId, languages) {
    emitter_1.emitter.supportedFilesLoaded(null);
    const resp = await (0, http_1.getFilters)(baseURL, source, undefined, requestId);
    if (resp.type === 'error') {
        throw resp.error;
    }
    const supportedFilesFromApi = resp.value;
    //Given supported languages from 'registy'
    if (languages) {
        const supportedFiles = {};
        supportedFiles.configFiles = supportedFilesFromApi.configFiles;
        supportedFiles.extensions = languages;
        //For verification only
        supportedFiles.extensions = supportedFiles.extensions.filter(langExtension => supportedFilesFromApi.extensions.includes(langExtension));
        emitter_1.emitter.supportedFilesLoaded(supportedFiles);
        return supportedFiles;
    }
    emitter_1.emitter.supportedFilesLoaded(supportedFilesFromApi);
    return supportedFilesFromApi;
}
/**
 * Creates a remote bundle and returns response from the bundle API
 *
 * @param {CreateBundleFromFoldersOptions} options
 * @returns {Promise<FileBundle | null>}
 */
async function createBundleFromFolders(options) {
    const baseDir = (0, files_1.determineBaseDir)(options.paths);
    const [supportedFiles, fileIgnores] = await Promise.all([
        // Fetch supporte files to save network traffic
        getSupportedFiles(options.baseURL, options.source, options.requestId, options.languages),
        // Scan for custom ignore rules
        (0, files_1.collectIgnoreRules)(options.paths, options.symlinksEnabled, options.defaultFileIgnores),
    ]);
    emitter_1.emitter.scanFilesProgress(0);
    const bundleFiles = [];
    const skippedOversizedFiles = [];
    let totalFiles = 0;
    const bundleFileCollector = (0, files_1.collectBundleFiles)({
        ...(0, lodash_pick_1.default)(options, ['paths', 'symlinksEnabled']),
        baseDir,
        fileIgnores,
        supportedFiles,
    });
    for await (const f of bundleFileCollector) {
        typeof f == 'string' ? skippedOversizedFiles.push(f) : bundleFiles.push(f);
        totalFiles += 1;
        emitter_1.emitter.scanFilesProgress(totalFiles);
    }
    const bundleOptions = {
        ...(0, lodash_pick_1.default)(options, ['baseURL', 'sessionToken', 'source', 'requestId', 'base64Encoding']),
        baseDir,
        files: bundleFiles,
    };
    // Create remote bundle
    if (!bundleFiles.length)
        return null;
    const remoteBundle = await remoteBundleFactory(bundleOptions);
    if (remoteBundle === null)
        return null;
    return {
        ...remoteBundle,
        baseDir,
        supportedFiles,
        fileIgnores,
        skippedOversizedFiles,
    };
}
exports.createBundleFromFolders = createBundleFromFolders;
//# sourceMappingURL=bundles.js.map