"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVerifyCallbackUrl = exports.getAnalysis = exports.AnalysisStatus = exports.extendBundle = exports.checkBundle = exports.createBundle = exports.getFilters = exports.checkSession = exports.getIpFamily = exports.startSession = exports.compressAndEncode = exports.setBase64Encoding = void 0;
const uuid_1 = require("uuid");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const zlib_1 = require("zlib");
const util_1 = require("util");
const constants_1 = require("./constants");
const needle_1 = require("./needle");
const url_1 = require("url");
// The trick to typecast union type alias
function isSubsetErrorCode(code, messages) {
    if (code in messages) {
        return true;
    }
    return false;
}
function generateError(errorCode, messages, apiName) {
    if (!isSubsetErrorCode(errorCode, messages)) {
        throw { errorCode, messages, apiName };
    }
    const statusCode = errorCode;
    const statusText = messages[errorCode];
    return {
        type: 'error',
        error: {
            apiName,
            statusCode,
            statusText,
        },
    };
}
const GENERIC_ERROR_MESSAGES = {
    [constants_1.ErrorCodes.serverError]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.serverError],
    [constants_1.ErrorCodes.badGateway]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.badGateway],
    [constants_1.ErrorCodes.serviceUnavailable]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.serviceUnavailable],
    [constants_1.ErrorCodes.timeout]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.timeout],
    [constants_1.ErrorCodes.dnsNotFound]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.dnsNotFound],
    [constants_1.ErrorCodes.connectionRefused]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.connectionRefused],
};
function setBase64Encoding(options) {
    if (!options.base64Encoding) {
        const { hostname } = new url_1.URL(options.baseURL);
        const rg = new RegExp('^(|dev.)snyk.io');
        if (rg.test(hostname.slice(hostname.indexOf('.') + 1))) {
            return options.base64Encoding;
        }
        else {
            return true;
        }
    }
    else {
        return options.base64Encoding;
    }
}
exports.setBase64Encoding = setBase64Encoding;
async function compressAndEncode(payload) {
    // encode payload and compress;
    const deflate = (0, util_1.promisify)(zlib_1.gzip);
    const compressedPayload = await deflate(Buffer.from(JSON.stringify(payload)).toString('base64'));
    return compressedPayload;
}
exports.compressAndEncode = compressAndEncode;
function startSession(options) {
    const { source, authHost } = options;
    const draftToken = (0, uuid_1.v4)();
    return {
        draftToken,
        loginURL: `${authHost}/login?token=${draftToken}&utm_medium=${source}&utm_source=${source}&utm_campaign=${source}&docker=false`,
    };
}
exports.startSession = startSession;
/**
 * Dispatches a FORCED IPv6 request to test client's ISP and network capability.
 *
 * @return {number} IP family number used by the client.
 */
async function getIpFamily(authHost) {
    const family = 6;
    // Dispatch a FORCED IPv6 request to test client's ISP and network capability
    const res = await (0, needle_1.makeRequest)({
        url: getVerifyCallbackUrl(authHost),
        method: 'post',
        family, // family param forces the handler to dispatch a request using IP at "family" version
    }, 0);
    const ipv6Incompatible = res.error;
    return ipv6Incompatible ? undefined : family;
}
exports.getIpFamily = getIpFamily;
const CHECK_SESSION_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.loginInProgress]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.loginInProgress],
};
async function checkSession(options) {
    const defaultValue = {
        type: 'success',
        value: '',
    };
    const res = await (0, needle_1.makeRequest)({
        url: getVerifyCallbackUrl(options.authHost),
        body: {
            token: options.draftToken,
        },
        family: options.ipFamily,
        method: 'post',
    });
    if (res.success) {
        return { ...defaultValue, value: (res.body.ok && res.body.api) || '' };
    }
    else if ([constants_1.ErrorCodes.loginInProgress, constants_1.ErrorCodes.badRequest, constants_1.ErrorCodes.unauthorizedUser].includes(res.errorCode)) {
        return defaultValue;
    }
    return generateError(res.errorCode, CHECK_SESSION_ERROR_MESSAGES, 'checkSession');
}
exports.checkSession = checkSession;
async function getFilters(baseURL, source, attempts = constants_1.MAX_RETRY_ATTEMPTS, requestId) {
    const apiName = 'filters';
    const res = await (0, needle_1.makeRequest)({
        headers: { source, ...(requestId && { 'snyk-request-id': requestId }) },
        url: `${baseURL}/${apiName}`,
        method: 'get',
    }, attempts);
    if (res.success) {
        return { type: 'success', value: res.body };
    }
    return generateError(res.errorCode, GENERIC_ERROR_MESSAGES, apiName);
}
exports.getFilters = getFilters;
function prepareTokenHeaders(sessionToken) {
    return {
        'Session-Token': sessionToken,
        // We need to be able to test code-client without deepcode locally
        Authorization: `Bearer ${sessionToken}`,
    };
}
const CREATE_BUNDLE_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedBundleAccess],
    [constants_1.ErrorCodes.bigPayload]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.bigPayload],
    [constants_1.ErrorCodes.badRequest]: `Request payload doesn't match the specifications`,
    [constants_1.ErrorCodes.notFound]: 'Unable to resolve requested oid',
};
async function createBundle(options) {
    const base64Encoding = setBase64Encoding(options);
    let payloadBody;
    if (base64Encoding) {
        payloadBody = await compressAndEncode(options.files);
    }
    else {
        payloadBody = options.files;
    }
    const payload = {
        headers: {
            ...prepareTokenHeaders(options.sessionToken),
            source: options.source,
            ...(options.requestId && { 'snyk-request-id': options.requestId }),
            ...(base64Encoding ? { 'content-type': 'application/octet-stream', 'content-encoding': 'gzip' } : null),
        },
        url: `${options.baseURL}/bundle`,
        method: 'post',
        body: payloadBody,
        isJson: base64Encoding ? false : true,
    };
    const res = await (0, needle_1.makeRequest)(payload);
    if (res.success) {
        return { type: 'success', value: res.body };
    }
    return generateError(res.errorCode, CREATE_BUNDLE_ERROR_MESSAGES, 'createBundle');
}
exports.createBundle = createBundle;
const CHECK_BUNDLE_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedBundleAccess],
    [constants_1.ErrorCodes.notFound]: 'Uploaded bundle has expired',
};
async function checkBundle(options) {
    const res = await (0, needle_1.makeRequest)({
        headers: {
            ...prepareTokenHeaders(options.sessionToken),
            source: options.source,
            ...(options.requestId && { 'snyk-request-id': options.requestId }),
        },
        url: `${options.baseURL}/bundle/${options.bundleHash}`,
        method: 'get',
    });
    if (res.success)
        return { type: 'success', value: res.body };
    return generateError(res.errorCode, CHECK_BUNDLE_ERROR_MESSAGES, 'checkBundle');
}
exports.checkBundle = checkBundle;
const EXTEND_BUNDLE_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.bigPayload]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.bigPayload],
    [constants_1.ErrorCodes.badRequest]: `Bad request`,
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: 'Unauthorized access to parent bundle',
    [constants_1.ErrorCodes.notFound]: 'Parent bundle has expired',
};
async function extendBundle(options) {
    const base64Encoding = setBase64Encoding(options);
    let payloadBody;
    if (base64Encoding) {
        payloadBody = await compressAndEncode((0, lodash_pick_1.default)(options, ['files', 'removedFiles']));
    }
    else {
        payloadBody = (0, lodash_pick_1.default)(options, ['files', 'removedFiles']);
    }
    const res = await (0, needle_1.makeRequest)({
        headers: {
            ...prepareTokenHeaders(options.sessionToken),
            source: options.source,
            ...(options.requestId && { 'snyk-request-id': options.requestId }),
            ...(base64Encoding ? { 'content-type': 'application/octet-stream', 'content-encoding': 'gzip' } : null),
        },
        url: `${options.baseURL}/bundle/${options.bundleHash}`,
        method: 'put',
        body: payloadBody,
        isJson: base64Encoding ? false : true,
    });
    if (res.success)
        return { type: 'success', value: res.body };
    return generateError(res.errorCode, EXTEND_BUNDLE_ERROR_MESSAGES, 'extendBundle');
}
exports.extendBundle = extendBundle;
// eslint-disable-next-line no-shadow
var AnalysisStatus;
(function (AnalysisStatus) {
    AnalysisStatus["waiting"] = "WAITING";
    AnalysisStatus["fetching"] = "FETCHING";
    AnalysisStatus["analyzing"] = "ANALYZING";
    AnalysisStatus["done"] = "DONE";
    AnalysisStatus["failed"] = "FAILED";
    AnalysisStatus["complete"] = "COMPLETE";
})(AnalysisStatus = exports.AnalysisStatus || (exports.AnalysisStatus = {}));
const GET_ANALYSIS_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedBundleAccess],
    [constants_1.ErrorCodes.notFound]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.notFound],
    [constants_1.ErrorCodes.badRequest]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.badRequest],
    [constants_1.ErrorCodes.serverError]: 'Getting analysis failed',
};
async function getAnalysis(options) {
    const config = {
        headers: {
            ...prepareTokenHeaders(options.sessionToken),
            source: options.source,
            ...(options.requestId && { 'snyk-request-id': options.requestId }),
        },
        url: `${options.baseURL}/analysis`,
        method: 'post',
        body: {
            key: {
                type: 'file',
                hash: options.bundleHash,
                limitToFiles: options.limitToFiles || [],
                ...(options.shard ? { shard: options.shard } : null),
            },
            ...(0, lodash_pick_1.default)(options, ['severity', 'prioritized', 'legacy', 'analysisContext']),
        },
    };
    const res = await (0, needle_1.makeRequest)(config);
    if (res.success)
        return { type: 'success', value: res.body };
    return generateError(res.errorCode, GET_ANALYSIS_ERROR_MESSAGES, 'getAnalysis');
}
exports.getAnalysis = getAnalysis;
function getVerifyCallbackUrl(authHost) {
    return `${authHost}/api/verify/callback`;
}
exports.getVerifyCallbackUrl = getVerifyCallbackUrl;
//# sourceMappingURL=http.js.map